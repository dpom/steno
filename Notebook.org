#+TITLE: Notebook
#+DESCRIPTION: notebook for pyproj project
#+AUTHOR: Dan Pomohaci
#+EMAIL: dan.pomohaci@gmail.com
#+STARTUP: overview indent align inlineimages
#+PROPERTY: header-args :cache yes :results silent :padline no

* 2024-12-29

- implement extract-words:
  #+begin_src clojure
(import [os.path :as path])

(path/exists "test.txt") ;;=> false


(import [cv2 :as cv2])

(def image (cv2/imread "test/resources/ex1.jpg"))

(defn extract-word-images
  [page-filename]
  (let [image (cv2/imread page-filename)
        gray (cv2/cvtColor image cv2/COLOR_BGR2GRAY)
        blur (cv2/GaussianBlur gray [5 5] 0)
        thresh (second (cv2/threshold blur 0 255 (+ cv2/THRESH_BINARY_INV
                                                    cv2/THRESH_OTSU)))
        kernel (cv2/getStructuringElement cv2/MORPH_RECT [7 7])
        dilate (cv2/dilate thresh kernel ** :iterations 1)
        cnts* (cv2/findContours dilate cv2/RETR_EXTERNAL cv2/CHAIN_APPROX_SIMPLE)
        cnts (if (= (count cnts*) 2) (first cnts*) (second cnts*))]
    (map (fn [contour]
           (let [[x y w h] (cv2/boundingRect contour)]
             (aget image #py ((slice y (+ y h)) (slice x (+ x w))))
             ))
         cnts)))


(def words (extract-word-images "test/resources/ex1.jpg"))

(cv2/boundingRect (first cnts))
;; => #py (2204 3239 10 8)

(let [[x y w h] (cv2/boundingRect (first cnts))]
  x)
;; => 2204

(class (first cnts))
;; => <class 'numpy.ndarray'>

(first words)
;; => array([[[247, 247, 247],
;;            [238, 238, 238],
;;            [229, 229, 229],
;;            [223, 223, 223],
;;            [216, 216, 216],
;;            [212, 212, 212],
;;            [202, 202, 202],
;;            [188, 188, 188],
;;            [175, 175, 175],
;;            [169, 169, 169]],
;;           [[242, 242, 242],
;;            [228, 228, 228],
;;            [214, 214, 214],
;;            [205, 205, 205],
;;            [192, 192, 192],
;;            [188, 188, 188],
;;            [183, 183, 183],
;;            [180, 180, 180],
;;            [179, 179, 179],
;;            [181, 181, 181]],
;;           [[226, 226, 226],
;;            [211, 211, 211],
;;            [198, 198, 198],
;;            [189, 189, 189],
;;            [162, 162, 162],
;;            [161, 161, 161],
;;            [161, 161, 161],
;;            [163, 163, 163],
;;            [167, 167, 167],
;;            [174, 174, 174]],
;;           [[202, 202, 202],
;;            [187, 187, 187],
;;            [175, 175, 175],
;;            [168, 168, 168],
;;            [142, 142, 142],
;;            [145, 145, 145],
;;            [151, 151, 151],
;;            [159, 159, 159],
;;            [170, 170, 170],
;;            [180, 180, 180]],
;;           [[182, 182, 182],
;;            [168, 168, 168],
;;            [159, 159, 159],
;;            [154, 154, 154],
;;            [151, 151, 151],
;;            [156, 156, 156],
;;            [166, 166, 166],
;;            [178, 178, 178],
;;            [191, 191, 191],
;;            [203, 203, 203]],
;;           [[175, 175, 175],
;;            [165, 165, 165],
;;            [159, 159, 159],
;;            [155, 155, 155],
;;            [168, 168, 168],
;;            [175, 175, 175],
;;            [186, 186, 186],
;;            [199, 199, 199],
;;            [211, 211, 211],
;;            [220, 220, 220]],
;;           [[183, 183, 183],
;;            [178, 178, 178],
;;            [175, 175, 175],
;;            [173, 173, 173],
;;            [180, 180, 180],
;;            [187, 187, 187],
;;            [199, 199, 199],
;;            [211, 211, 211],
;;            [220, 220, 220],
;;            [225, 225, 225]],
;;           [[199, 199, 199],
;;            [198, 198, 198],
;;            [198, 198, 198],
;;            [197, 197, 197],
;;            [192, 192, 192],
;;            [200, 200, 200],
;;            [212, 212, 212],
;;            [225, 225, 225],
;;            [233, 233, 233],
;;            [236, 236, 236]]], dtype=uint8)

(cv2/imwrite "tmp/words/word000.png" (first words))

(format "test %03d" 1)
;; => "test 001"

(map-indexed #(println (str %1 "-" %2)) cnts)

(defn save-words-image
  [words outdir]
  (map-indexed #(cv2/imwrite (format "%s/word%03d.png" outdir %1) %2)  words))

(save-words-image words "tmp/words")

(defmacro mget [m r1 r2 c1 c2]
  `(aget ~m (python/tuple [(python/slice ~r1 ~r2) (python/slice ~c1 ~c2)])))
  #+end_src

* 2025-01-01

- incerc sa reduc grosimea liniilor la un pixel:
  #+begin_src clojure
(import
  [cv2 :as cv2]
  [numpy :as np]
  [matplotlib :as matp]
  [matplotlib.pyplot :as plt])

;; (matp/use "tkagg")

(def img (cv2/imread "test/resources/orig.png"))

(def edges (cv2/Canny  img 100 200))

(defn show
  [img]
  (plt/imshow img ** :cmap "gray")
  (plt/show))

(show img)
(show edges)
;; Valuerror: 'gtkagg' is not a valid value for backend; supported values are ['gtk3agg', 'gtk3cairo', 'gtk4agg', 'gtk4cairo', 'macosx', 'nbagg', 'notebook', 'qtagg', 'qtcairo', 'qt5agg', 'qt5cairo', 'tkagg', 'tkcairo', 'webagg', 'wx', 'wxagg', 'wxcairo', 'agg', 'cairo', 'pdf', 'pgf', 'ps', 'svg', 'template']
  #+end_src 

* 2025-01-02

- continui cu modificarea parametrilor de la canny:
  #+begin_src clojure
(import
  [cv2 :as cv2]
  [numpy :as np]
  [matplotlib :as matp]
  [matplotlib.pyplot :as plt])


(def img (cv2/imread "test/resources/orig.png"))


(defn show
  [img]
  (plt/imshow img ** :cmap "gray")
  (plt/show))


(def edges (cv2/Canny  img 100 200))

(show edges)
  #+end_src

* 2025-01-03

- incerc noi methode:
  #+begin_src clojure
(import
  [cv2 :as cv2])

(require '[steno.utils :as utl])

(def img (cv2/imread "test/resources/words/word010.png"))

(utl/show img)
  #+end_src

* 2025-01-04

- testez metoda gasita in https://docs.opencv.org/3.4/d9/d61/tutorial_py_morphological_ops.html
  #+begin_src clojure
(import
  [cv2 :as cv2]
  [numpy :as np])

(require '[steno.utils :as utl])

(def img (cv2/imread "test/resources/words/word010.png"))

(utl/show img)

(def invert (cv2/bitwise_not img))

(utl/show invert)


(def kernel (np/ones [5 5] np/uint8))

(def erosion (cv2/erode invert kernel ** :iterations 1))

(utl/show erosion)
  #+end_src

- testez metoda gasita in https://theailearner.com/tag/skeletonization-opencv/:
  #+begin_src clojure
(import
  [cv2 :as cv2]
  [numpy :as np])

(require '[steno.utils :as utl])

(def img (cv2/imread "test/resources/words/word010.png"))

(utl/show img)

;; inversez imaginea
(def invert (cv2/bitwise_not img))

(utl/show invert)

;; incerc o filtrare intai 

kernel = np.ones((5,5),np.float32)/25
dst = cv.filter2D(img,-1,kernel)

(def kernel (/ (np/ones [5 5] np/float32) 25))

(def filter-img (cv2/filter2D invert -1 kernel))

(utl/show filter-img)

;; blur

(def blur (cv2/blur invert [5,5]))

(utl/show blur)

;; skeletonization

(def kernel (cv2/getStructuringElement cv2/MORPH_CROSS [3 3]))

(def thin (np/zeros (.- blur shape) ** :dtype "uint8"))

(cv2/countNonZero thin)


(def img2
  (loop [image blur
         result thin]
    (println "step")
    (if (zero? (cv2/countNonZero image))
      result
      (let [erode (cv2/erode image kernel)
            opening (cv2/morphologyEx erode cv2/MORPH_OPEN kernel)
            subset (- erode opening)]
        (recur erode (cv2/bitwise_or subset result))))))

;; binary

(def bin-image
  (second (cv2/threshold blur 175 255 cv2/THRESH_BINARY)))

(utl/show bin-image)

  #+end_src
- incerc scikit
  #+begin_src clojure
(import
  [cv2 :as cv2]
  [numpy :as np]
  [skimage.morphology :as skim])
(require '[steno.utils :as utl])

(def img
  (-> (cv2/imread "test/resources/words/word010.png")
      (cv2/bitwise_not)
      (cv2/blur [5,5])))



(import [skimage.morphology :as skim])




(def img1  (skim/skeletonize img))


(import [skimage.util :as skiu])

(def img2
  (skiu/img_as_ubyte img1))



(utl/show img2)

(def img
  (-> (cv2/imread "test/resources/words/word010.png")
      (cv2/bitwise_not)
      (cv2/blur [5,5])
      (skim/skeletonize)
      (skiu/img_as_ubyte)))

(utl/show img)
  #+end_src

* 2025-01-12

** #5 Convert a word image in a number sequence

- afiseaza o matrice binara:
  #+begin_src clojure
;; import numpy as np
;; import matplotlib.pyplot as plt

;; # create a random binary bidimensional matrix of size 10x10
;; matrix = np.random.randint(2, size=(10, 10))

;; plt.imshow(matrix, cmap='binary', interpolation='nearest')
;; plt.show()


(import
  [numpy.random :as np]
  [cv2 :as cv2]
  [matplotlib :as matp]
  [matplotlib.pyplot :as plt])

(matp/use "tkagg")


(def matrix (np/randint 2 ** :size [10 10]))

(plt/imshow matrix ** :cmap "gray" :interpolation "nearest")

(plt/show)

(defn show-matrix
  [mat]
  (plt/imshow mat ** :cmap "gray" :interpolation "nearest")
  (plt/show))

(show-matrix matrix)

(defn convert-cell
  [val]
  (println (apply + val))
  (if (zero? (apply + val)) 0 1))

(def img (cv2/imread "test/resources/words/word010.png"))


(def word010
  (mapv #(mapv convert-cell %) img))

(show-matrix word010)

(def bw (cv2/threshold img 127 255 cv2/THRESH_BINARY))

(require '[steno.utils :as utl])

(utl/show bw)


(let [shape (.- img shape)]
  (def rows (first shape))
  (def cols (second shape)))


;; => #py (62 256 3)

(zero? (apply + (aget img 2 2)))

;; => np.uint8(0)

(defn convert-image
  [img]
  (let [[rows cols _] (.- img shape)]
    (mapv (fn [i]
            (mapv (fn [j]
                    (if (bool (zero? (apply + (aget img i j)))) 0 1))
                  (range 0 cols)))
          (range 0 rows))))

(def word010 (convert-image img))

(show-matrix word010)

# 8 151-161

(bool (zero? (apply + (aget img 8 151))))
;; => false

(bool (zero? (apply + (aget img 8 150))))
;; => true


;; => np.False_




  #+end_src

* 2025-01-13

** #5 Convert a word image in a number sequence

- continui implementarea converter:
  #+begin_src clojure
(def directions
  [[ 0  1] ; E
   [ 1  1] ; SE
   [ 1  0] ; S
   [ 1 -1] ; SV
   [ 0 -1] ; V
   [-1 -1] ; NV
   [-1  0] ; N
   [-1  1] ; NE
   ])

(def matrix
  [[0 0 0]
   [0 1 1]
   [0 0 0]])


(aget matrix 1 1)
;; => 1


(defn get-neighbor
  [mat [r c] [dr dc]]
  (try
    (aget mat (+ r dr) (+ c dc))
    (catch Exception e
      0)))

(get-neighbor matrix [1 1] (first directions))
;; => 1

(get-neighbor matrix [1 1] (nth directions 2))
;; => 0

(get-neighbor matrix [0 0] (nth directions 4))
;; => 0

(defn get-cell-number
  [mat point]
  (reduce (fn [[count num] dir]
            (let [v (get-neighbor mat point dir)]
              [(+ count v) (+ (* num 2) v)]))
          [0 0]
          directions))

(get-cell-number matrix [1 1])
;; => [1 128]

(format "%x" 128)
;; => "80"


(get-cell-number matrix [2 1])
;; => [3 11]

(format "%x" 11)
;; => "b"
;; 1011

(doseq [d directions]
  (println (get-neighbor matrix [2 1] d)))

(def mat1
  [[6 7 8]
   [5 0 1]
   [4 3 2]])

(mapv #(get-neighbor mat1 [1 1] %) directions)
;; => [1 2 3 4 5 6 7 8]

(mapv #(get-neighbor mat1 [2 1] %) directions)
;; => [2 0 0 0 4 5 0 1]
  #+end_src
  
* 2025-01-14


** #5 Convert a word image in a number sequence

- continui implementarea converter:
  #+begin_src clojure
(require '[steno.converter :as cnv]
         '[steno.utils :as utl])

(defn get-neighbor
  [mat [r c] [dr dc]]
  (let [nr (+ r dr)
        nc (+ c dc)]
    (try
      [[nr nc] (aget mat nr nc)]
      (catch Exception e
        [[-1 -1] 0]))))


(defn get-cell-number-and-neighbors
  [mat point]
  (reduce (fn [[neighbors num] dir]
            (let [[np v] (get-neighbor mat point dir)]
              [(if (zero? v) neighbors (conj neighbors np)) (+ (* num 2) v)]))
          [#{} 0]
          cnv/directions))

(def mat1
  [[6 7 8]
   [5 0 1]
   [4 3 2]])

(mapv #(get-neighbor mat1 [1 1] %) cnv/directions)
;; => [[[1 2] 1] [[2 2] 2] [[2 1] 3] [[2 0] 4] [[1 0] 5] [[0 0] 6] [[0 1] 7] [[0 2] 8]]

(def mat2
  [[1 1 1]
   [1 0 1]
   [1 1 1]])

(get-cell-number-and-neighbors mat2 [1 1])
;; => [#{[1 2] [2 2] [1 0] [0 2] [2 0] [0 1] [0 0] [2 1]} 255]


(defn get-liniar-sequence
  [mat start-cell prev-cell acc]
  (let [[neighbors val] (get-cell-number-and-neighbors mat start-cell)
        new-neighbors (disj neighbors prev-cell)
        new-acc (conj acc val)
        num (count new-neighbors)]
    (cond
      (zero? num) [[-1 -1] start-cell new-acc]
      (= num 1) (get-liniar-sequence mat (first new-neighbors) start-cell new-acc)
      :else [start-cell prev-cell acc])))

(defn get-start-cell
  [mat strict?]
  (let [max-column (count mat)
        max-row (count (first mat))]
    (loop [column 0
           row 0]
      (let [[neighbors _] (get-cell-number-and-neighbors mat [row column])
            n (count neighbors)][]
        (if (or (and strict? (= 1 n))
                (> n 0))
          [row column]
          (let [new-row (+ row 1)
                new-column (if (= new-row max-row) (+ column 1) column)
                new-row (if (= new-row max-row) 0 new-row)]
            (if (= new-column max-column)
              [-1 -1]
              (recur new-column new-row))))))))


(import [cv2 :as cv2])


(def word010 (cnv/image->matrix (cv2/imread "test/resources/words/word010.png")))

(utl/show-matrix word010)

(get-start-cell word010 true)
;; => [42 6]

(get-liniar-sequence word010 [42 6] [-1 -1] [])
;; => [[34 150] [35 149] [64 128 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 9 144 136 136 72 132 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 72 132 136 72 132 136 136 136 136 136 136 136 136 72 132 136 136 136 9 144 136 136 136 136 72 132 136 72 68 68 68 68 36 66 132 136 136 136 136 136 136 136 136 9 144 9 144 136 9 144 9 144 136 136 136 136 9 144 136 136 9 144 136 136 136 9 144 136 136 9 144 136 136 136 9 17 17 144 136 136 9 144 136 136 9 144 9 17 18 33]]
  #+end_#+begin_src  

  #+end_src

* 2025-01-15

** #5 Convert a word image in a number sequence

#+begin_src clojure
  (def neighbors
    (-> (get-cell-number-and-neighbors word010 [34 150])
        first
        (disj [35 149])))
  ;; => #{[33 149] [34 151]}
  
  (def seq1 (get-liniar-sequence word010 [33 149] [34 150] []))
  ;; => [[29 177] [28 177] [66 34 36 66 36 68 68 68 66 34 34 34 34 34 36 66 34 34 33 18 33 17 17 17 144 136 9 144 136 136 136 136 136 136 136 136 136 72 132 136 136 136 136 136 136 72 132 72 68 68 68 68 36 34 34 34 34 66 36 18 33 34 66 36 34 34]]

  (def seq2 (get-liniar-sequence word010 [34 151] [34 150] []))
  seq2
  ;; => [[30 176] [31 175] [136 136 136 136 136 136 136 72 5 144 136 136 136 136 136 136 136 9 17 144 136 136 9 144 9]]

  (defn get-next-neighbors
    [mat start-cell prev-cell]
    (-> (get-cell-number-and-neighbors word010 start-cell)
        first
        (disj prev-cell)))

  (get-next-neighbors word010 [29 177] [28 177])
  ;; => #{[30 177] [30 176]}

  (get-next-neighbors word010 [30 176] [31 175])
  ;; => #{[30 177] [29 177]}

  (get-cell-number-and-neighbors word010 [30 177])
  ;; => [#{[30 176] [31 178] [29 177]} 74]

  (require '[basilisp.set :as set])

  (def start-cell [34 150])

  (def prev-cell [35 149])
  
  
  (def neighbors (get-next-neighbors word010 start-cell prev-cell))
  ;; => #{[33 149] [34 151]}

  (def res (map (fn [cell]
                  (get-liniar-sequence word010 cell start-cell []))
                neighbors))
  ;; => ([[29 177] [28 177] [66 34 36 66 36 68 68 68 66 34 34 34 34 34 36 66 34 34 33 18 33 17 17 17 144 136 9 144 136 136 136 136 136 136 136 136 136 72 132 136 136 136 136 136 136 72 132 72 68 68 68 68 36 34 34 34 34 66 36 18 33 34 66 36 34 34]] [[30 176] [31 175] [136 136 136 136 136 136 136 72 5 144 136 136 136 136 136 136 136 9 17 144 136 136 9 144 9]])

  (def seqs (mapv #(nth % 2) res))
  ;; => [[66 34 36 66 36 68 68 68 66 34 34 34 34 34 36 66 34 34 33 18 33 17 17 17 144 136 9 144 136 136 136 136 136 136 136 136 136 72 132 136 136 136 136 136 136 72 132 72 68 68 68 68 36 34 34 34 34 66 36 18 33 34 66 36 34 34] [136 136 136 136 136 136 136 72 5 144 136 136 136 136 136 136 136 9 17 144 136 136 9 144 9]]

  (def new-prevs (set (map first res)))
  
  (def next-neighbors
    (->> res
         (map (fn [[start prev _]]
                (get-next-neighbors word010 start prev)))
         (apply set/union)
         (set)))
  ;; => #{[30 177] [30 176] [29 177]}

  (def next (first (set/difference next-neighbors new-prevs)))
  
  (def next-res (get-cell-number-and-neighbors word010 next))
  ;; => [#{[30 176] [31 178] [29 177]} 74]

  (def new-start-cell (-> (first next-res)
                          (set/difference next-neighbors)
                          first))
  
  (defn get-parallel-sequence
    [mat start prev]
    (let [neighbors (get-next-neighbors mat start prev)
          res (map (fn [cell]
                     (get-liniar-sequence mat cell start []))
                   neighbors)
          seqs (mapv #(nth % 2) res)
          new-prevs (set (map first res))
          next-neighbors (->> res
                              (map (fn [[s p _]]
                                     (get-next-neighbors mat s p)))
                              (apply set/union)
                              (set))
          new-prev (first (set/difference next-neighbors new-prevs))
          [new-neighbors _] (get-cell-number-and-neighbors mat new-prev)
          new-start (-> new-neighbors
                        (set/difference next-neighbors)
                        first)]
      [new-start new-prev seqs]))

  
  (defn matrix->numseq
    [mat start-cell]
    (loop [start start-cell
           prev dummy-cell
           acc []]
      (let [[new-start new-prev seq] (get-liniar-sequence mat start prev [])]
        (if (= new-start dummy-cell)
          (conj acc seq)
          (let [[st pr pseqs] (get-parallel-sequence mat new-start new-prev)]
            (recur st pr (conj acc seq pseqs)))))))

  (matrix->numseq word010 [42 6])
  ;; => [[64 128 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 9 144 136 136 72 132 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 72 132 136 72 132 136 136 136 136 136 136 136 136 72 132 136 136 136 9 144 136 136 136 136 72 132 136 72 68 68 68 68 36 66 132 136 136 136 136 136 136 136 136 9 144 9 144 136 9 144 9 144 136 136 136 136 9 144 136 136 9 144 136 136 136 9 144 136 136 9 144 136 136 136 9 17 17 144 136 136 9 144 136 136 9 144 9 17 18 33] [[66 34 36 66 36 68 68 68 66 34 34 34 34 34 36 66 34 34 33 18 33 17 17 17 144 136 9 144 136 136 136 136 136 136 136 136 136 72 132 136 136 136 136 136 136 72 132 72 68 68 68 68 36 34 34 34 34 66 36 18 33 34 66 36 34 34] [136 136 136 136 136 136 136 72 5 144 136 136 136 136 136 136 136 9 17 144 136 136 9 144 9]] [132 72 132 136 136 72 132 136 136 136 72 132 72 132 136 136 136 136 72 132 136 136 72 132 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 9 17 17 17 17 17 17 17 17 17 18 34 33 18 34 34 32]]

#+end_src

* 2025-01-19

- calcul numar de biti:
  #+begin_src clojure
(def masks [1 2 4 8 16 32 64 128])

(defn count-bits [oct]
  (reduce (fn [acc mask]
            (if (zero? (bit-and mask oct))
              acc
              (inc acc)))
          0
          masks))

(count-bits 3)
;; => 2

(count-bits 255)
;; => 8
  #+end_src

* 2025-01-20

** #9 Build the "standard" sequences

- extrag secventele standard:
  #+begin_src clojure
(import [cv2 :as cv2])

(require
  '[steno.utils :as utl]
  '[steno.converter :as cnv])

(def t-template (cnv/image->matrix (cv2/imread "tmp/templates/word022.png")))

(utl/show-matrix t-template)

(cnv/get-start-cell t-template true)
;; => [5 5]

(def t-symbol (cnv/matrix->numseq t-template))
t-symbol
;; => [[128 136 136 136 136 136 136 136 136 136 72 132 136 136 136 136 136 136 72 132 136 136 136 136 136 8]]

(format "%x" 128)

(cnv/get-next-neighbors t-template [5 5] [-1 -1])
;; => #{[5 6]}

(cnv/get-next-neighbors t-template [5 6] [-1 -1])
;; => #{[5 7] [5 5]}


(def d-template (cnv/image->matrix (cv2/imread "tmp/templates/word023.png")))

(utl/show-matrix d-template)

(cnv/ged-start-cell d-template true)
;; => [5 5]

(def d-symbol (cnv/matrix->numseq d-template))
d-symbol
;; => [[128 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 8]]
  #+end_src 

* 2025-01-22

** #9 Build the "standard" sequences

- extrag secventele standard:
  #+begin_src clojure
(import [cv2 :as cv2])

(require
  '[steno.utils :as utl]
  '[steno.converter :as cnv])

(def t-symbol (first t-symbol))
;; => [64 128 136 136 136 136 136 136 136 136 136 72 132 136 136 136 136 136 136 72 132 136 136 136 136 136 8]

(count t-symbol)
;; => 27

(def d-symbol (first d-symbol))
;; => [128 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 8]

(count d-symbol)
;; => 74


(def p-template (cnv/->matrix (cv2/imread "tmp/templates/word024.png")))

(utl/show-matrix p-template)

(def p-symbol (first (cnv/matrix->numseq p-template)))
;; => [32 34 34 34 34 34 34 34 34 34 66 36 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 2]
(count p-symbol)
;; => 29


(def b-template (cnv/image->matrix (cv2/imread "tmp/templates/word029.png")))

(utl/show-matrix b-template)

(def b-symbol (first (cnv/matrix->numseq b-template)))
;; => [32 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 66 36 34 34 34 34 66 36 34 34 34 34 34 34 34 34 34 34 34 34 34 34 18 33 34 34 34 34 34 34 34 34 18 33 34 34 34 34 34 34 34 34 34 2]

(count b-symbol)
;; => 67

(def fv-template (cnv/image->matrix (cv2/imread "tmp/templates/word031.png")))

(utl/show-matrix fv-template)

(def f-symbol (first (cnv/matrix->numseq fv-template)))
f-symbol
;; => [32 66 36 34 66 36 66 68 68 68 68 36 66 36 66 36 66 68 68 4]

(count f-symbol)
;; => 20

(def pat-template (cnv/image->matrix (cv2/imread "tmp/templates/word007.png")))

(utl/show-matrix pat-template)

(cnv/get-start-cell pat-template true)
;; => [41 5]


(def pat-symbol (cnv/matrix->numseq pat-template))
pat-symbol
;; => [[] [[18 33 18 33 17 144 136 136 136 136 136 9] [34 34 34 66 36 34 66 68 68 68 132 136 136 136 9 18 33 17 18 34 34 34 34 34 34 34 34 33 18]] [] [[9 136 136 136 136 136 144 17 33 18 33 18 33 34 34 34 66 36 34 66 68 68 68 132 136 136 136 9 18 33 17 18 34 34 34 34 34 34 34 34 33 18] [68]] [9 144 136 136 136 136 136 136 136 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 8]]

  #+end_src 

* 2025-02-19

** #9 Build the "standard" sequences

- nu cred ca are rost sa folosesc secvente pentru litere lungi (b, d, g, si r), pot sa le echivalez cu doua litere scurte.
  #+begin_src shell
bb app test/resources/template.png tmp/templates/
  #+end_src
- extrag templates
  #+begin_src clojure
(import [cv2 :as cv2])

(require
  '[steno.utils :as utl]
  '[steno.converter :as cnv])

(def t-template (cnv/image->matrix (cv2/imread "tmp/templates/word022.png")))

(utl/show-matrix t-template)

(count t-template)
;; => 13


(def p-template (cnv/image->matrix (cv2/imread "tmp/templates/word023.png")))

(cnv/get-start-cell p-template true)
;; => [8 6]

(cnv/get-cell-number-and-neighbors p-template [8 6])
;; => [#{[7 7] [9 6]} 33]
(cnv/get-cell-number-and-neighbors p-template [8 5])
;; => [#{[9 6] [8 6]} 192]


(utl/show-matrix p-template)

(count p-template)
;; => 44

(def c-template (cnv/image->matrix (cv2/imread "tmp/templates/word026.png")))

(cnv/get-start-cell c-template true)
;; => [28 10]

(utl/show-matrix c-template)

(count c-template)
;; => 44

  #+end_src
- am o eroare in converter la calculul celulei de start:
  #+begin_src clojure
(comment

  (import [cv2 :as cv2])

  (require '[steno.utils :as utl])

  (def p-template (image->matrix (cv2/imread "tmp/templates/word023.png")))
  
  (utl/show-matrix p-template)

  (count p-template)
  ;; => 44

  (get-start-cell p-template true)
  ;; => [8 6]
  
  (def t [[1 2 3]
          [4 5 6]
          [7 8 9]])
  
  
  (aget t 0 2)
  ;; => 3

  (aget t 1 0)
  ;; => 4

  (get-cell-value t 0 2)
  ;; => 3
  
  (get-cell-value t 1 0)
  ;; => 4

  (map #(get-neighbor t [1 1] %) directions)
  ;; => ([[1 2] 6] [[2 2] 9] [[2 1] 8] [[2 0] 7] [[1 0] 4] [[0 0] 1] [[0 1] 2] [[0 2] 3])

  (map #(get-neighbor t [0 1] %) directions)
  ;; => ([[0 2] 3] [[1 2] 6] [[1 1] 5] [[1 0] 4] [[0 0] 1] [[-1 0] 0] [[-1 1] 0] [[-1 2] 0])

  (pos? 0)
  ;; => false

  (def t1 [[1 1 1]
           [1 1 1]
           [1 1 1]])

  (get-cell-number-and-neighbors t1 [1 1])
  ;; => [#{[1 2] [2 2] [1 0] [0 2] [2 0] [0 1] [0 0] [2 1]} 255]
  
  (def t2 [[0 0 0]
           [0 1 1]
           [0 0 0]])

  (get-cell-number-and-neighbors t2 [1 1])
  ;; => [#{[1 2]} 128]

  (class t-template)
  (class t2)
  ;; => <class 'basilisp.lang.vector.PersistentVector'>

  (count t2)
  ;; => 3

  (count p-template)
  ;; => 44

  (count (first p-template))
  ;; => 13
  
  (get-start-cell p-template true)
  ;; => [14 5]

  (utl/show-matrix p-template)

  (get-start-cells p-template)
  ;; => [[5 8] [38 6]]


  (get-cell-number-and-neighbors p-template [6 7])
  ;; => [#{[7 7] [5 8]} 33]

  (get-cell-number-and-neighbors p-template [5 8])
  
  (get-start-cells t-template)
  ;; => [[5 42] [7 6]]
  
  (utl/show-matrix t-template)

  (defn get-min-start-cell [cells]
    (first
      (reduce (fn [[min-cell sum] cell]
                (let [new-sum (apply + cell)]
                  (if (< new-sum sum)
                    [cell new-sum]
                    [min-cell sum])))
              [dummy-cell (float "inf")]
              cells)))

  (get-min-start-cell (get-start-cells t-template))
  ;; => [7 6]
  
  (get-min-start-cell (get-start-cells p-template))
  ;; => [5 8]

  (defn get-first-one [mat]
    (let [max-row (count mat)
          max-col (count (first mat))]
      (loop [row 0
             col 0]
        (if (= (get-cell-value mat row col) 1)
          [row col]
          (let [new-col (inc col)
                new-row (if (= new-col max-col) (inc row) row)
                new-col (if (= new-row row) new-col 0)]
            (if (= new-row max-row) 
              dummy-cell
              (recur new-row new-col)))))))

  (get-first-one t-template)
  ;; => [5 16]

  (defn get-start-cell
    [mat]
    (let [cells (get-start-cells mat)]
      (case (count cells)
        0 (get-first-one mat)
        1 (first cells)
        (get-min-start-cell cells))))

  (get-start-cell t-template)
  ;; => [7 6]

  (get-start-cell p-template)
  ;; => [5 8]
  
  
  ;;
  )
  #+end_src
- continui constructia secventelor standard
  #+begin_src clojure
(import [cv2 :as cv2])

(require
  '[steno.utils :as utl]
  '[steno.converter :as cnv])

(def p-template (cnv/image->matrix (cv2/imread "tmp/templates/word023.png")))
  
(def t-template (cnv/image->matrix (cv2/imread "tmp/templates/word022.png")))

(def c-template (cnv/image->matrix (cv2/imread "tmp/templates/word026.png")))


(def p-seq (first (cnv/matrix->numseq p-template)))
;; => [16 33 18 33 34 34 34 34 18 33 34 34 34 34 34 66 36 18 33 34 34 34 34 66 36 34 34 34 34 34 34 34 34 2]

(count p-seq)
;; => 34


(def t-seq (first (cnv/matrix->numseq t-template)))
;; => [128 136 136 136 136 9 144 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 8]

(count t-seq)
;; => 37

(def c-seq  (first (cnv/matrix->numseq c-template)))
;; => [16 33 18 33 18 33 18 17 33 18 33 18 17 33 18 33 18 33 18 33 18 17 33 18 17 33 18 17 17 1]

(count c-seq)
;; => 30

(def pat-template (cnv/image->matrix (cv2/imread "tmp/templates/word007.png")))

(cnv/get-start-cell pat-template)
;; => [5 16]


(utl/show-matrix pat-template)

(def pat-seq (cnv/matrix->numseq pat-template))
;; => [[32 34 34 34 34 34 34 34 34 34 34 34 66 36 34 34 34 34 34 34 34 34 18 33 34 34 34 34 34] [[9 136 136 136 136 136 144 17 33 18 33 18 33 34 34 34 66 36 34 66 68 68 68 132 136 136 136 9 18 33 17 18 34 34 34 34 34 34 34 34 33 18] [68]] [9 144 136 136 136 136 136 136 136 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 8]]

(count (first pat-seq))
;; => 29

(count (last pat-seq))
;; => 28

(def pot-template (cnv/image->matrix (cv2/imread "tmp/templates/word008.png")))

(cnv/get-start-cell pot-template)
;; => [6 31]


(utl/show-matrix pot-template)

(def pot-seq (cnv/matrix->numseq pot-template))
;; => [[32 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 34 66 36 34 34 34 34 34 34 34 34 34 34 34 34 34 34] [[] [] []] [136 136 136 136 136 136 136 136 72 132 136 136 136 136 136 136 136 136 72 132 136 136 72 132 136 136 136 136 136 136 8]]

(count (first pot-seq))
;; => 34

(count (last pot-seq))
;; => 31
  #+end_src

* 2025-02-21

** #9 Build the "standard" sequences

- am o eroare in converter la calculul secventelor paralele:
  #+begin_src clojure
(comment

  (import [cv2 :as cv2])

  (require '[steno.utils :as utl])

  (def p-template (image->matrix (cv2/imread "tmp/templates/word023.png")))
  
  (def t-template (image->matrix (cv2/imread "tmp/templates/word022.png")))

  (def c-template (image->matrix (cv2/imread "tmp/templates/word026.png")))

  (def p-seq (matrix->numseq p-template))
  ;; => [[16 33 18 33 34 34 34 34 18 33 34 34 34 34 34 66 36 18 33 34 34 34 34 66 36 34 34 34 34 34 34 34 34 2]]

  
  
  (def t-seq (matrix->numseq t-template))
  ;; => [[128 136 136 136 136 9 144 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 8]]

  (def c-seq  (matrix->numseq c-template))
  ;; => [[16 33 18 33 18 33 18 17 33 18 33 18 17 33 18 33 18 33 18 33 18 17 33 18 17 33 18 17 17 1]]
  

  (utl/show-matrix c-template)

  (require '[basilisp-pprint.pprint :as p])


  (def big-map (zipmap
                 [:a :b :c :d :e]
                 (repeat
                   (zipmap [:a :b :c :d :e]
                           (take 5 (range))))))
  ;; => #'user/big-map

  big-map
  ;; => {:e {:e 4 :a 0 :c 2 :d 3 :b 1} :a {:e 4 :a 0 :c 2 :d 3 :b 1} :c {:e 4 :a 0 :c 2 :d 3 :b 1} :d {:e 4 :a 0 :c 2 :d 3 :b 1} :b {:e 4 :a 0 :c 2 :d 3 :b 1}}

  (p/pprint big-map)

  (p/print-table [:a] [{:a [1 2 3]} {:a 7}])

  (defn print
    [map]
    (p/print-table (keys map) [map]))
  

  (print {:a 2 :b {:a 1 :b "cucu"}})

  (add-tap (bound-fn* print))

  (tap> {:a 2 :b 5})

  (def pat-template (image->matrix (cv2/imread "tmp/templates/word007.png")))

  (utl/show-matrix pat-template)

  (def pat-seq (matrix->numseq pat-template))
  pat-seq
  ;; => [[32 34 34 34 34 34 34 34 34 34 34 34 66 36 34 34 34 34 34 34 34 34 18 33 34 34 34 34 34] [[9 136 136 136 136 136 144 17 33 18 33 18 33 34 34 34 66 36 34 66 68 68 68 132 136 136 136 9 18 33 17 18 34 34 34 34 34 34 34 34 33 18] [68]] [9 144 136 136 136 136 136 136 136 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 8]]
)
  ;;
    #+end_src
- nu am gasit nici o eroare

* 2025-02-22

- as vrea sa implementez o functie numseq->matrix pentru a putea afisa si numseq calculate
  #+begin_src clojure

(require '[steno.utils :as utl])

(import [numpy :as np])


(add-tap (bound-fn* utl/print4tap))

(tap> {:a 1 :b 2})


(def mat (np/zeros [10 10] ** :dtype "int"))

mat
(aset mat 1 2 1)

(defn cells->matrix
  [size cells]
  (let [mat (np/zeros size ** :dtype "int")]
    (doseq [[x y] cells]
      (aset mat x y 1))
    mat))

(cells->matrix [3 3] [[0 2] [1 1] [2 2]])
;; => array([[0, 0, 1],
;;           [0, 1, 0],
;;           [0, 0, 1]])

0x100

(require '[steno.converter :as cnv])

(/ 0x100 2)

(range 0 0x100 2)
;; => (0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 102 104 106 108 110 112 114 116 118 120 122 124 126 128 130 132 134 136 138 140 142 144 146 148 150 152 154 156 158 160 162 164 166 168 170 172 174 176 178 180 182 184 186 188 190 192 194 196 198 200 202 204 206 208 210 212 214 216 218 220 222 224 226 228 230 232 234 236 238 240 242 244 246 248 250 252 254)

2r10

(def pos [2r10000000
          2r01000000
          2r00100000
          2r00010000
          2r00001000
          2r00000100
          2r00000010
          2r00000001])

(def num 2)

(def cell [100 100])

(defn extract-cells
  [num [x y]]
  (set (filter identity
               (map (fn [[dx dy] p]
                      (if (zero? (bit-and num p))
                        nil
                        [(+ x dx) (+ y dy)]))
                    cnv/directions pos))))



(extract-cells 0x0f [10 10])

(defn numseq->matrix
  [numseq]
  (let [start-cell [100 100]
        cells* (:cells (reduce (fn [{:keys [cells start prev] :as acc} num]
                                 (tap> acc)
                                 (let [new-cells (-> num
                                                     (extract-cells start)
                                                     (disj prev))]
                                   (tap> {:new-cells new-cells})
                                   {:cells (into cells new-cells)
                                    :start (first new-cells)
                                    :prev start}))
                               {:cells #{start-cell}
                                :start start-cell
                                :prev cnv/dummy-cell}
                               numseq))
        x-min (dec (apply min (map first cells*)))
        y-min (dec (apply min (map second cells*)))
        cells (mapv (fn [[x y]] [(- x x-min) (- y y-min)]) cells*)
        x-max (inc (apply max (map first cells)))
        y-max (inc (apply max (map second cells)))]
    (cells->matrix [x-max y-max] cells)))


(import [cv2 :as cv2])

(def p-template (cnv/image->matrix (cv2/imread "tmp/templates/word023.png")))

(def p-seq (first (cnv/matrix->numseq p-template)))
;; => [16 33 18 33 34 34 34 34 18 33 34 34 34 34 34 66 36 18 33 34 34 34 34 66 36 34 34 34 34 34 34 34 34 2]

(def p-seq* (numseq->matrix p-seq))

(utl/show-matrix p-seq*)
  #+end_src

* 2025-02-24

- incerc "netezirea" numseq pentru a elimina diferentele. Folosesc mediana si un factor de grupare initial 5:
  #+begin_src clojure
(import [cv2 :as cv2])

(require
  '[steno.utils :as utl]
  '[steno.converter :as cnv])

(def p-template* (cnv/image->matrix (cv2/imread "tmp/templates/word023.png")))

(def t-template* (cnv/image->matrix (cv2/imread "tmp/templates/word022.png")))

(def c-template* (cnv/image->matrix (cv2/imread "tmp/templates/word026.png")))


(def p-seq* (first (cnv/matrix->numseq p-template*)))
p-seq*
;; => [16 33 18 33 34 34 34 34 18 33 34 34 34 34 34 66 36 18 33 34 34 34 34 66 36 34 34 34 34 34 34 34 34 2]


(utl/show-matrix p-template*)

(defn median
  [coll]
  (let [sorted (sort coll)
        cnt (count sorted)
        halfway (quot cnt 2)]
    (nth sorted halfway)))

(def smooth-bin-length 5)

(defn smooth-numseq
  [numseq bin-length]
  (let [start (first numseq)
        smooth-bins (partition-all bin-length (rest numseq))]
    (into [start] (map median smooth-bins))))


(def p-seq (smooth-numseq p-seq* 5))
;; => [16 33 34 34 34 34 34 34]

(def p-template (cnv/numseq->matrix p-seq))
(def p-template (cnv/numseq->matrix [32 34 34 34 34 34 34 34]))

(utl/show-matrix p-template)

(add-tap (bound-fn* utl/print4tap))

(def start-cell [100 100])



(defn num2cells
  [numseq ]
  (loop [
         acc #{start-cell}
         todo (queue [[start-cell cnv/dummy-cell]])]
    (tap> acc)
    (if (and (empty? nums)(empty? todo)
             acc
             (let [[start prev] (peek todo)
                   new-cells (-> num
                                 (cnv/extract-neighbors start)
                                 (disj prev))]
               (tap> {:new-cells new-cells})
               (recur (into acc new-cells)
                      (into (pop todo) (map (fn [cell] [cell start]) new-cells))))))))

(8 [start-cell cnv/dummy-cell])

  (def t-seq* (first (cnv/matrix->numseq t-template*)))
  ;; => [128 136 136 136 136 9 144 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 8]

  (def t-seq (smooth-numseq t-seq* 5))
  t-seq
  ;; => [128 136 136 136 136 136 136 136 8]

(def t-template (cnv/numseq->matrix t-seq))

(utl/show-matrix t-template)

(def c-seq* (first (cnv/matrix->numseq c-template*)))

(def c-seq (smooth-numseq c-seq* 5))
c-seq
;; => [16 33 18 18 18 18 17]

(def c-template (cnv/numseq->matrix c-seq))

(utl/show-matrix c-template)

(def f-template* (cnv/image->matrix (cv2/imread "tmp/templates/word025.png")))

(utl/show-matrix f-template*)

(def f-seq* (first (cnv/matrix->numseq f-template*)))

(def f-seq (smooth-numseq f-seq* 5))
f-seq
;; => [32 68 68 36 66 66 66 36]

(def f-template (cnv/numseq->matrix f-seq))

(utl/show-matrix f-template)

(def l-template* (cnv/image->matrix (cv2/imread "tmp/templates/word024.png")))

(utl/show-matrix l-template*)

(def l-seq* (first (cnv/matrix->numseq l-template*)))
l-seq*
;; => [128 9 144 136 9 144 136 9 144 9 17 144 136 9 144 136 9 144 9 144 9 144 9 144 9 144 136 9 144 9 144 136 9 144 9 144 9 144 136 9 144 136 9 17 144 9 16]


(def l-seq (smooth-numseq l-seq* 5))
l-seq
;; => [128 136 17 136 9 144 136 136 136 17 16]

(def l-template (cnv/numseq->matrix l-seq))

(utl/show-matrix l-template)

(defn build-model
  [fileimage bin-length]
  (let [template* (cnv/image->matrix (cv2/imread fileimage))
        numseq* (first (cnv/matrix->numseq template*))
        numseq (smooth-numseq numseq* bin-length)
        template (cnv/numseq->matrix numseq)
        model {:numseq* numseq*
               :numseq numseq}]
    (tap> model)
    (utl/show-matrix template*)
    (utl/show-matrix template)
    (assoc model :template template :template* template*)))

(def l-model (build-model "tmp/templates/word024.png" 5))
(def j-model (build-model "tmp/templates/word020.png" 3))

(import [matplotlib.pyplot :as plt])

(defn show-templates
  [img1 img2]
  (let [[fig axs] (plt/subplots 1 2 ** :figsize [100 100])]
    (.imshow (first axs) img1 ** :cmap "gray" :vmin 0 :vmax 1)
    (.imshow (second axs) img2 ** :cmap "gray" :vmin 0 :vmax 1)
    ;; (plt/tight_layout)
    (plt/show)))

(show-templates (:template* l-model) (:template l-model))

(defn build-model
  [fileimage bin-length]
  (let [template* (cnv/image->matrix (cv2/imread fileimage))
        numseq* (first (cnv/matrix->numseq template*))
        numseq (smooth-numseq numseq* bin-length)
        template (cnv/numseq->matrix numseq)
        model {:numseq* numseq*
               :numseq numseq}]
    (tap> model)
    (show-templates template* template)
    (assoc model :template template :template* template*)))

(def j-model (build-model "tmp/templates/word020.png" 3))
(def n-model (build-model "tmp/templates/word018.png" 3))
(def m-model (build-model "tmp/templates/word017.png" 3))

(import
  [cv2 :as cv2]
  [numpy :as np])

(def map (:template* m-model))

(def binary-image
  (-> [100 100]
      (np/zeros ** :dtype np/uint8)
      (cv2/line [10 90] [90 10] 1 2)))

(utl/show-matrix binary-image)


(def extract-contours
  [map]
  (let [image (.astype (* map 255) np/uint8)]) )
  #+end_src

* 2025-02-25

- incerc o noua abordare pentru netezire:
  #+begin_src clojure

(import
  [cv2 :as cv2]
  [numpy :as np]
  [matplotlib.pyplot :as plt]
  [PIL.Image :as pil])


(defn image2binary
  [image-filename]
  (let [selector (fn [p] (if (> p 128) 255 0))]
    (-> image-filename
        (pil/open)
        (.convert "L")
        (.point selector)
        (np/array)
        (/ 255)
        (.astype "int"))))

(def j-mat (image2binary "tmp/templates/word020.png"))

(require
  '[steno.utils :as utl]
  '[steno.converter :as cnv])

(defn show-templates
  [img1 img2]
  (let [[fig axs] (plt/subplots 1 2 ** :figsize [100 100])]
    (.imshow (first axs) img1 ** :cmap "gray" :vmin 0 :vmax 1)
    (.imshow (second axs) img2 ** :cmap "gray" :vmin 0 :vmax 1)
    ;; (plt/tight_layout)
    (plt/show)))

(show-templates j-mat j-mat)



(defn extract-contours
  [mat]
  (let [image (.astype (* mat 255) np/uint8)
        [contours _] (cv2/findContours image cv2/RETR_EXTERNAL, cv2/CHAIN_APPROX_SIMPLE)]
    (mapv #(.squeeze %) contours)))

(extract-contours j-mat)
  #+end_src
- creare matrice dintr-o lista de celule:
  #+begin_src python
import numpy as np

def create_array_from_cells(cells, array_size):
    """
    Create a 2D array from a sequence of cells.

    Args:
        cells (list of tuples): List of tuples where each tuple represents the coordinates (x, y)
        array_size (tuple): Size of the output array (height, width)

    Returns:
        np.ndarray: A 2D array with 1s in the specified cells and 0s elsewhere.
    """
    # Create a 2D array filled with zeros
    array = np.zeros(array_size, dtype=int)

    # Set the specified cells to 1
    for (x, y) in cells:
        if 0 <= x < array_size[0] and 0 <= y < array_size[1]:  # Check bounds
            array[x, y] = 1

    return array

# Example usage:
if __name__ == "__main__":
    cells = [(1, 2), (3, 4), (0, 0), (2, 1)]
    array_size = (5, 5)  # Size of the output array (5 rows, 5 columns)
    
    result_array = create_array_from_cells(cells, array_size)
    
    print("The 2D array is:")
    print(result_array)

  #+end_src
- afisare a 2 matrici:
  #+begin_src python
import numpy as np
import matplotlib.pyplot as plt

# Create two binary matrices
matrix1 = np.array([[1, 0, 1], [0, 1, 0], [1, 1, 1]])
matrix2 = np.array([[0, 1, 0], [1, 0, 1], [0, 0, 0]])

# Set up the figure and axes
fig, ax = plt.subplots(1, 2, figsize=(8, 4))

# Display the first binary matrix
ax[0].imshow(matrix1, cmap='gray', vmin=0, vmax=1)
ax[0].set_title('Matrix 1')
ax[0].axis('off')  # Turn off the axis

# Display the second binary matrix
ax[1].imshow(matrix2, cmap='gray', vmin=0, vmax=1)
ax[1].set_title('Matrix 2')
ax[1].axis('off')  # Turn off the axis

# Show the plot
plt.tight_layout()
plt.show()

  #+end_src
- algoritmul de netezire Douglas-Peucker:
  #+begin_src python
import numpy as np
import cv2

def douglas_peucker(points, epsilon):
    """
    The Douglas-Peucker algorithm implementation.

    :param points: Array of points to be simplified.
    :param epsilon: The tolerance value for simplification.
    :return: The simplified array of points.
    """
    # Find the start and end points
    start, end = points[0], points[-1]

    # If there's only 2 points, return them
    if len(points) < 3:
        return np.array([start, end])

    # Calculate the distance from the line segment to all points
    line_vec = end - start
    line_vec = line_vec / np.linalg.norm(line_vec)  # Normalize
    points_vec = points - start
    projection = np.dot(points_vec, line_vec)
    
    # Get the perpendicular distance to the line
    # Distance = ||points_vec - projection * line_vec||
    perpendicular_distances = np.linalg.norm(points_vec - np.outer(projection, line_vec), axis=1)

    # Find the index of the point with the maximum distance
    max_distance_index = np.argmax(perpendicular_distances)

    # If the maximum distance is greater than epsilon, recursively simplify
    if perpendicular_distances[max_distance_index] > epsilon:
        # Recursively simplify
        left_simplified = douglas_peucker(points[:max_distance_index + 1], epsilon)
        right_simplified = douglas_peucker(points[max_distance_index:], epsilon)

        # Combine results
        return np.vstack((left_simplified[:-1], right_simplified))
    else:
        return np.array([start, end])
    

def extract_contours(binary_image):
    """
    Extract contours from a binary image.

    :param binary_image: Binary image with 1s (white) and 0s (black).
    :return: Contours found in the image.
    """
    # Convert the binary image to uint8
    binary_image = (binary_image * 255).astype(np.uint8)
    
    # Find contours
    contours, _ = cv2.findContours(binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    return [contour.squeeze() for contour in contours]

def main():
    # Create a binary image for testing
    binary_image = np.zeros((100, 100), dtype=np.uint8)
    cv2.line(binary_image, (10, 90), (90, 10), 1, 2)

    # Extract contours
    contours = extract_contours(binary_image)
    
    # Simplify each contour using Douglas-Peucker
    epsilon = 5.0  # Tolerance for simplification
    simplified_contours = [douglas_peucker(contour, epsilon) for contour in contours]
    
    # Visualize results
    for contour in simplified_contours:
        contour = np.int32(contour)  # Convert to int32 for drawing
        cv2.polylines(binary_image, [contour], isClosed=False, color=2, thickness=1)
    
    cv2.imshow("Original Binary Image", binary_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()

  #+end_src
  rezultatele nu sunt grozave
- conversie imagine la matrice binara:
  #+begin_src python
from PIL import Image
import numpy as np

def image_to_binary_matrix(image_path):
    # Open the image
    img = Image.open(image_path)
    
    # Convert the image to grayscale
    gray_img = img.convert('L')
    
    # Convert the grayscale image to binary (0 and 255)
    # You can adjust the threshold as needed
    threshold = 128
    binary_img = gray_img.point(lambda p: 255 if p > threshold else 0)
    
    # Convert binary image to a numpy array
    binary_data = np.array(binary_img)

    # Convert the binary data to a binary matrix (0s and 1s)
    binary_matrix = (binary_data / 255).astype(int)
    
    return binary_matrix

# Example usage
image_path = 'path_to_your_image.jpg'
binary_matrix = image_to_binary_matrix(image_path)

print(binary_matrix)
  #+end_src
- algoritmul de netezire LOESS:
  - prima versiune
    #+begin_src python
import numpy as np
from scipy.ndimage import gaussian_filter

def loess_smoothing(binary_image, bandwidth=1.0):
    """
    Apply LOESS smoothing to a binary image.
    
    Parameters:
        binary_image (numpy.ndarray): Input binary image (2D array with values 0 and 1).
        bandwidth (float): The bandwidth (size of neighborhood) for the LOESS fitting.
        
    Returns:
        numpy.ndarray: Smoothed image.
    """
    # Ensure binary_image is a numpy array
    binary_image = np.asarray(binary_image, dtype=float)

    # Create a smooth representation of the binary image
    smoothed = np.zeros_like(binary_image)

    # Get the dimensions of the image
    rows, cols = binary_image.shape

    # Apply LOESS smoothing
    for i in range(rows):
        for j in range(cols):
            # Define the range of the neighborhood
            x_min = max(0, i - int(bandwidth))
            x_max = min(rows, i + int(bandwidth) + 1)
            y_min = max(0, j - int(bandwidth))
            y_max = min(cols, j + int(bandwidth) + 1)

            # Extract the neighborhood
            neighborhood = binary_image[x_min:x_max, y_min:y_max]

            # Generate a meshgrid for distances
            x_indices, y_indices = np.meshgrid(np.arange(x_min, x_max), np.arange(y_min, y_max))
            distances = np.sqrt((x_indices - i) ** 2 + (y_indices - j) ** 2)

            # We use a tricube weight function
            weights = np.clip(1 - (distances / bandwidth) ** 3, 0, 1) ** 3

            # Sum the weights and the weighted values
            weighted_sum = np.sum(weights * neighborhood)
            weight_sum = np.sum(weights)

            # Calculate the smoothed value (avoid division by zero)
            smoothed[i, j] = weighted_sum / weight_sum if weight_sum > 0 else 0

    return smoothed


# Example usage
if __name__ == "__main__":
    # Create a simple binary image
    binary_img = np.array([[0, 0, 1, 1, 0],
                            [0, 1, 1, 1, 0],
                            [1, 1, 1, 1, 1],
                            [0, 1, 1, 1, 0],
                            [0, 0, 1, 0, 0]])

    # Apply LOESS smoothing
    smoothed_image = loess_smoothing(binary_img, bandwidth=1.0)

    # Print the smoothed image
    print("Original binary image:\n", binary_img)
    print("Smoothed image:\n", smoothed_image)

  #+end_src
  - a doua versiune:
    #+begin_src python
import numpy as np

def tricube_weight(distance, bandwidth):
    """ Tri-cube weight function for LOESS """
    if abs(distance) <= bandwidth:
        return (1 - (distance / bandwidth) ** 3) ** 3
    else:
        return 0

def loess_smoothing(image, bandwidth):
    """ Perform LOESS smoothing on a 2D image """
    smoothed_image = np.zeros_like(image, dtype=float)
    rows, cols = image.shape

    for i in range(rows):
        for j in range(cols):
            weights = []
            values = []
            
            # Gathering weights and values within bandwidth
            for k in range(max(0, i - int(bandwidth)): min(rows, i + int(bandwidth + 1))):
                for l in range(max(0, j - int(bandwidth)): min(cols, j + int(bandwidth + 1))):
                    distance = np.sqrt((i - k) ** 2 + (j - l) ** 2)
                    weight = tricube_weight(distance, bandwidth)
                    weights.append(weight)
                    values.append(image[k, l])

            # Weighted average calculation
            weights = np.array(weights)
            values = np.array(values)
            if np.sum(weights) > 0:  # Avoid division by zero
                smoothed_image[i, j] = np.sum(weights * values) / np.sum(weights)
            else:
                smoothed_image[i, j] = image[i, j]  # Default to original if no weights

    return smoothed_image

# Example usage
if __name__ == "__main__":
    # Create a simple binary image
    binary_img = np.array([[0, 0, 1, 1, 0],
                            [0, 1, 1, 1, 0],
                            [1, 1, 1, 1, 1],
                            [0, 1, 1, 1, 0],
                            [0, 0, 1, 0, 0]])

    # Apply LOESS smoothing
    smoothed_image = loess_smoothing(binary_img, bandwidth=1.0)

    # Print the smoothed image
    print("Original binary image:\n", binary_img)
    print("Smoothed image:\n", smoothed_image)
    #+end_src
  nu aduce nici o imbunatatire
- The Gaussian kernel (also known as the radial basis function or RBF kernel) is commonly used in machine learning, particularly in support vector machines and kernelized algorithms. The Gaussian kernel is defined as:
  #+begin_example
[ K(x, y) = e^{-\frac{|x - y|^2}{2\sigma^2}}]

Where:

( K(x, y) ) is the Gaussian kernel function,
( x ) and ( y ) are input vectors,
( |x - y| ) is the Euclidean distance between the vectors,
( \sigma ) is a parameter that controls the width of the Gaussian kernel.
   #+end_example
   #+begin_src python
import numpy as np

def gaussian_kernel(x, y, sigma):
    """
    Compute the Gaussian kernel between two vectors.

    Parameters:
    x : array-like, shape (n_features,)
        First input vector.
    y : array-like, shape (n_features,)
        Second input vector.
    sigma : float
        The width of the Gaussian kernel.

    Returns:
    float
        The value of the Gaussian kernel evaluated at x and y.
    """
    distance = np.linalg.norm(x - y)
    kernel_value = np.exp(- (distance ** 2) / (2 * sigma ** 2))
    return kernel_value

# Example usage
x = np.array([1.0, 2.0])
y = np.array([2.0, 3.0])
sigma = 1.0

kernel_value = gaussian_kernel(x, y, sigma)
print(f"Gaussian Kernel between x and y: {kernel_value}")
  #+end_src
- The Savitzky-Golay filter is a popular technique used in signal processing to smooth data and to calculate the derivatives of a signal. It fits successive sub-intervals of the data with a low-degree polynomial by the method of linear least squares. Here's a simple implementation of the Savitzky-Golay filter in Python using NumPy:
  #+begin_src python
import numpy as np
from scipy.signal import savgol_filter
import matplotlib.pyplot as plt

def apply_savitzky_golay_filter(data, window_size, poly_order):
    """
    Apply Savitzky-Golay filter to the input data.

    Parameters:
    data (array-like): Input data to be filtered.
    window_size (int): The length of the filter window (must be a positive odd integer).
    poly_order (int): The order of the polynomial used to fit the samples (must be less than window_size).

    Returns:
    array: Smoothed data.
    """
    if window_size % 2 == 0 or window_size < 1:
        raise ValueError("window_size must be a positive odd integer.")
    if poly_order >= window_size:
        raise ValueError("poly_order must be less than window_size.")

    # Apply the Savitzky-Golay filter
    filtered_data = savgol_filter(data, window_size, poly_order)
    return filtered_data

# Example usage
if __name__ == "__main__":
    # Generating sample data
    np.random.seed(0)
    x = np.linspace(0, 10, 100)
    y = np.sin(x) + np.random.normal(0, 0.1, x.shape)  # Sine wave with added noise

    # Applying Savitzky-Golay filter
    window_size = 11  # Length of the filter window
    poly_order = 2    # Polynomial order
    smoothed_y = apply_savitzky_golay_filter(y, window_size, poly_order)

    # Plotting the results
    plt.figure(figsize=(12, 6))
    plt.plot(x, y, label='Noisy Signal', alpha=0.5)
    plt.plot(x, smoothed_y, label='Savitzky-Golay Filtered Signal', color='red')
    plt.legend()
    plt.title('Savitzky-Golay Filter Example')
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.grid()
    plt.show()
#+end_src

* 2025-02-26

- incercarile de ieri nu au fost utile incerc din nou:
  #+begin_src clojure
(import
  [cv2 :as cv2]
  [matplotlib :as matp])

(require
  '[steno.utils :as utl]
  '[steno.converter :as cnv])

(add-tap (bound-fn* utl/print4tap))

(matp/use "tkagg")

(defn build-model
  [fileimage]
  (let [template* (cnv/image2matrix (cv2/imread fileimage))
        numseq* (first (cnv/matrix2numseq template*))
        model   {:numseq* numseq*}]
    (tap> model)
    (utl/show-matrix template*)
    (assoc model :template* template*)))


(defn get-liniar-contour
  "Return a liniar contour (list of cells).

   Params:
   - mat : the word matrix
   - start-cell : [row column]
   - prev-cell : previous cell in sequence (dummy cell if new sequence)

   Returns: [next-start-cell next-prev-cell contour]  "
  [mat start-cell prev-cell]
  (loop [start start-cell
         prev prev-cell
         acc [start-cell]]
    (let [[neighbors val] (cnv/get-cell-number-and-neighbors mat start)
          new-neighbors (disj neighbors prev)
          num (count new-neighbors)
          new-acc (if (zero? num) acc (conj acc (first new-neighbors)))]
      (tap> {:cell start :val val :neighbors new-neighbors})
      (tap> {:new-acc new-acc})
      (cond
        (zero? num) [cnv/dummy-cell start new-acc]
        (= num 1) (recur (first new-neighbors) start new-acc)
        :else [start prev acc]))))

(defn get-contours
  [mat]
  (let [start (cnv/get-start-cell mat)]
    (last (get-liniar-contour mat start cnv/dummy-cell))))

(def p-model (build-model "tmp/templates/word023.png"))

(def cells* (get-contours (:template* p-model)))

(def mat2 (utl/cells2matrix [50 50] cells*))

(utl/show-matrix mat2)

(sort-by (fn [[x y]] (+ x y)) (take 5 cells))
;; => ([5 8] [6 7] [7 7] [8 6] [9 6])

(defn median
  [cells]
  (let [sorted (sort-by (fn [[x y]] (+ x y)) cells)
        cnt (count sorted)
        halfway (quot cnt 2)]
    (nth sorted halfway)))

(defn smooth-contour
  [contour bin-size]
  (let [start (first contour)
        smooth-bins (partition-all bin-size (rest contour))]
    (into [start] (map median smooth-bins))))

(def cells (smooth-contour cells* 5))

(def mat3 (utl/cells2matrix [50 50] cells))

(utl/show-matrix mat3)


(defn smooth-numseq
  [numseq bin-length]
  (let [start (first numseq)
        smooth-bins (partition-all bin-length (rest numseq))]
    (into [start] (map median smooth-bins))))

(def bin-size 5)

(defn build-model
  [fileimage]
  (let [template* (cnv/image2matrix (cv2/imread fileimage))
        numseq* (first (cnv/matrix2numseq template*))
        numseq (smooth-numseq numseq* bin-size)
        template (cnv/numseq2matrix numseq)
        model {:numseq* numseq*
               :numseq numseq}]
    (tap> model)
    (utl/show-two-matrices template* template)
    (assoc model :template template :template* template*)))

(def p-model (build-model "tmp/templates/word023.png"))
(def t-model (build-model "tmp/templates/word022.png"))
(def c-model (build-model "tmp/templates/word026.png"))
(def f-model (build-model "tmp/templates/word025.png"))
(def l-model (build-model "tmp/templates/word024.png"))
(def j-model (build-model "tmp/templates/word020.png"))
(def n-model (build-model "tmp/templates/word018.png"))
(def m-model (build-model "tmp/templates/word017.png"))
(def s-model (build-model "tmp/templates/word016.png"))

(def joc-mat* (cnv/image2matrix (cv2/imread "tmp/templates/word002.png")))

(utl/show-matrix joc-mat*)

(cnv/get-start-cell joc-mat*)
;; => [38 5]


(def joc-numseq* (cnv/matrix2numseq joc-mat*))
joc-numseq*
;; => Unbound(var=#'user/joc-numseq*)
  #+end_src
- este o eroare la functia matrix2numseq care face ca functia sa ruleze la infinit in cazul in care imaginea contine secvente paralele:
  #+begin_src clojure
(comment

  (import [cv2 :as cv2])

  (def joc-mat* (image2matrix (cv2/imread "tmp/templates/word002.png")))

  (utl/show-matrix joc-mat*)

  (def start-cell (get-start-cell joc-mat*))

  (add-tap (bound-fn* utl/print4tap))

  (def seq0 (get-liniar-sequence joc-mat* {:start-cell start-cell
                                           :prev-cells #{}}))
  seq0
  {:prev-cells #{[26 7] [6 35] [11 17] [34 5] [20 59] [8 21] [22 9] [31 5] [18 58] [7 42] [28 6] [6 34] [7 25] [38 5] [11 16] [23 9] [6 37] [12 15] [10 49] [9 20] [21 9] [12 52] [6 30] [6 33] [32 5] [9 19] [22 61] [19 10] [30 5] [36 5] [6 32] [27 7] [10 18] [10 50] [13 14] [21 60] [6 38] [16 56] [25 8] [7 26] [24 63] [6 28] [8 47] [7 23] [20 10] [37 5] [6 31] [7 41] [16 12] [14 13] [8 46] [17 57] [6 40] [29 6] [7 24] [33 5] [8 45] [14 54] [24 8] [15 13] [11 51] [6 36] [19 59] [9 48] [15 55] [6 39] [8 44] [17 11] [23 62] [35 5] [6 29] [8 22] [13 53] [7 27] [18 11] [8 43]}
   :start-cells #{[24 64] [25 64]}
   :numseq [2 34 34 34 34 34 34 34 33 18 33 18 33 18 33 18 34 33 18 33 18 33 17 18 33 17 17 144 9 17 144 9 144 9 144 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 72 132 72 132 136 136 136 72 68 132 72 68 68 68 68 68 68 68 68 36 66 68 68 68 196]}


  (def seq1 (get-parallel-sequence joc-mat* seq0))
  seq1
  {:prev-cells #{[26 7] [6 35] [11 17] [34 5] [20 59] [8 21] [22 9] [31 5] [18 58] [7 42] [28 6] [27 64] [6 34] [7 25] [38 5] [11 16] [23 9] [6 37] [12 15] [10 49] [9 20] [21 9] [12 52] [6 30] [6 33] [29 65] [32 5] [9 19] [22 61] [19 10] [30 5] [36 5] [6 32] [27 7] [10 18] [10 50] [24 64] [13 14] [21 60] [6 38] [16 56] [25 8] [7 26] [30 65] [24 63] [6 28] [8 47] [7 23] [20 10] [37 5] [6 31] [7 41] [16 12] [14 13] [8 46] [17 57] [6 40] [29 6] [7 24] [33 5] [8 45] [14 54] [24 8] [15 13] [25 64] [11 51] [6 36] [19 59] [9 48] [15 55] [26 64] [6 39] [8 44] [28 64] [17 11] [23 62] [35 5] [6 29] [8 22] [13 53] [7 27] [18 11] [8 43]} :start-cells #{[31 66] [31 64] [23 65] [25 64]} :numseq [[41] [38 34 34 66 36 82]]}

  (def seq3 (get-parallel-sequence joc-mat* seq1))
  seq3
  {:prev-cells #{[26 7] [6 35] [46 52] [18 96] [11 17] [34 5] [20 59] [8 21] [14 78] [43 54] [27 97] [36 75] [22 9] [31 5] [18 58] [31 66] [52 49] [7 42] [37 86] [28 6] [60 44] [42 55] [14 84] [53 48] [27 64] [14 87] [37 85] [14 90] [56 46] [6 34] [7 25] [38 5] [11 16] [39 57] [23 9] [37 79] [6 37] [12 15] [26 97] [44 53] [47 52] [17 73] [10 49] [19 71] [37 58] [49 51] [9 20] [34 72] [35 91] [31 64] [21 9] [14 83] [12 52] [15 93] [21 68] [34 61] [37 84] [6 30] [14 89] [6 33] [50 50] [29 65] [32 5] [29 97] [37 78] [51 49] [15 92] [9 19] [32 94] [48 51] [34 92] [24 97] [37 77] [55 46] [14 79] [32 62] [22 61] [35 90] [14 82] [32 68] [19 10] [30 5] [23 97] [23 65] [14 85] [31 67] [36 5] [6 32] [14 88] [27 7] [33 93] [33 61] [10 18] [37 81] [10 50] [24 64] [13 14] [21 60] [36 59] [6 38] [16 56] [14 81] [25 8] [7 26] [30 65] [59 44] [24 63] [6 28] [8 47] [38 83] [31 63] [22 67] [31 95] [7 23] [20 10] [37 5] [6 31] [37 80] [36 87] [58 44] [7 41] [34 73] [16 12] [21 96] [54 47] [14 77] [14 13] [38 82] [20 96] [16 75] [8 46] [30 96] [17 57] [15 91] [33 70] [14 80] [6 40] [25 97] [18 72] [28 97] [29 6] [7 24] [20 70] [33 69] [57 45] [33 5] [23 66] [14 86] [17 95] [8 45] [14 54] [24 8] [15 13] [36 76] [25 64] [11 51] [41 55] [40 56] [35 60] [6 36] [36 89] [16 74] [19 59] [9 48] [15 55] [26 64] [34 71] [6 39] [15 76] [8 44] [22 96] [45 53] [19 96] [28 64] [35 74] [17 11] [23 62] [36 88] [35 5] [6 29] [38 58] [8 22] [13 53] [7 27] [20 69] [18 11] [16 94] [8 43]}
   :start-cells #{}
   :numseq [[132 72 68 132 72 132 136 72 68 132 72 132 136 136 136 72 132 9 144 136 9 144 136 9 144 9 17 17 17 17 17 18 34 34 34 34 34 36 66 34 34 34 36 68 68 72 136 132 72 136 136 136 136 136 136 136 136 136 136 136 136 144 17 9 144 17 17 17 9 144 17 17 9 144] [9 144 17 33 18 17 17 33 18 17 17 33 18 17 33 18 33 18 33 18 17 33 18 17 17 33 18 17 33 34 2]]}

  (matrix2numseq joc-mat*)
  ;; => [[2 34 34 34 34 34 34 34 33 18 33 18 33 18 33 18 34 33 18 33 18 33 17 18 33 17 17 144 9 17 144 9 144 9 144 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 72 132 72 132 136 136 136 72 68 132 72 68 68 68 68 68 68 68 68 36 66 68 68 68 196] [[41] [38 34 34 66 36 82]] [[132 72 68 132 72 132 136 72 68 132 72 132 136 136 136 72 132 9 144 136 9 144 136 9 144 9 17 17 17 17 17 18 34 34 34 34 34 36 66 34 34 34 36 68 68 72 136 132 72 136 136 136 136 136 136 136 136 136 136 136 136 144 17 9 144 17 17 17 9 144 17 17 9 144] [9 144 17 33 18 17 17 33 18 17 17 33 18 17 33 18 33 18 33 18 17 33 18 17 17 33 18 17 33 34 2]]]
  ;;
  )
  #+end_src

* 2025-02-28

- am refactorizat converter si am trecut de la numseq la lineseq
  #+begin_src clojure
(comment

  (import [cv2 :as cv2])

  (add-tap (bound-fn* utl/print4tap))

  (matrix2lineseq joc-mat*)
  [
   [[38 5 2] [37 5 34] [36 5 34] [35 5 34] [34 5 34] [33 5 34] [32 5 34] [31 5 34] [30 5 33] [29 6 18] [28 6 33] [27 7 18] [26 7 33] [25 8 18] [24 8 33] [23 9 18] [22 9 34] [21 9 33] [20 10 18] [19 10 33] [18 11 18] [17 11 33] [16 12 17] [15 13 18] [14 13 33] [13 14 17] [12 15 17] [11 16 144] [11 17 9] [10 18 17] [9 19 144] [9 20 9] [8 21 144] [8 22 9] [7 23 144] [7 24 136] [7 25 136] [7 26 136] [7 27 9] [6 28 144] [6 29 136] [6 30 136] [6 31 136] [6 32 136] [6 33 136] [6 34 136] [6 35 136] [6 36 136] [6 37 136] [6 38 136] [6 39 136] [6 40 72] [7 41 132] [7 42 72] [8 43 132] [8 44 136] [8 45 136] [8 46 136] [8 47 72] [9 48 68] [10 49 132] [10 50 72] [11 51 68] [12 52 68] [13 53 68] [14 54 68] [15 55 68] [16 56 68] [17 57 68] [18 58 68] [19 59 36] [20 59 66] [21 60 68] [22 61 68] [23 62 68] [24 63 196]]
   [[[24 64 41]]
    [[25 64 38] [26 64 34] [27 64 34] [28 64 66] [29 65 36] [30 65 82]]]
   [[[31 66 132] [31 67 72] [32 68 68] [33 69 132] [33 70 72] [34 71 132] [34 72 136] [34 73 72] [35 74 68] [36 75 132] [36 76 72] [37 77 132] [37 78 136] [37 79 136] [37 80 136] [37 81 72] [38 82 132] [38 83 9] [37 84 144] [37 85 136] [37 86 9] [36 87 144] [36 88 136] [36 89 9] [35 90 144] [35 91 9] [34 92 17] [33 93 17] [32 94 17] [31 95 17] [30 96 17] [29 97 18] [28 97 34] [27 97 34] [26 97 34] [25 97 34] [24 97 34] [23 97 36] [22 96 66] [21 96 34] [20 96 34] [19 96 34] [18 96 36] [17 95 68] [16 94 68] [15 93 72] [15 92 136] [15 91 132] [14 90 72] [14 89 136] [14 88 136] [14 87 136] [14 86 136] [14 85 136] [14 84 136] [14 83 136] [14 82 136] [14 81 136] [14 80 136] [14 79 136] [14 78 136] [14 77 144] [15 76 17] [16 75 9] [16 74 144] [17 73 17] [18 72 17] [19 71 17] [20 70 9] [20 69 144] [21 68 17] [22 67 17] [23 66 9] [23 65 144]]
    [[31 64 9] [31 63 144] [32 62 17] [33 61 33] [34 61 18] [35 60 17] [36 59 17] [37 58 33] [38 58 18] [39 57 17] [40 56 17] [41 55 33] [42 55 18] [43 54 17] [44 53 33] [45 53 18] [46 52 33] [47 52 18] [48 51 33] [49 51 18] [50 50 17] [51 49 33] [52 49 18] [53 48 17] [54 47 17] [55 46 33] [56 46 18] [57 45 17] [58 44 33] [59 44 34] [60 44 2]]]]

  (defn build-model
    [fileimage]
    (let [mat* (image2matrix (cv2/imread fileimage))
          lineseq* (matrix2lineseq mat*)]
      {:mat* mat*
       :lineseq* lineseq*}))
  
  (def o-model (build-model "tmp/templates/word021.png"))
  
  (:lineseq* o-model)
  [[[6 20 144]]
   [[[7 19 17] [8 18 17] [9 17 9] [9 16 144] [10 15 9] [10 14 144] [11 13 9] [11 12 144] [12 11 17] [13 10 17] [14 9 17] [15 8 17] [16 7 17] [17 6 33] [18 6 18] [19 5 33] [20 5 34] [21 5 34] [22 5 34] [23 5 34] [24 5 34] [25 5 66] [26 6 36] [27 6 34] [28 6 34] [29 6 34] [30 6 66] [31 7 68] [32 8 68] [33 9 68] [34 10 68] [35 11 68] [36 12 132] [36 13 72] [37 14 132] [37 15 72] [38 16 5] [37 17 144] [37 18 136] [37 19 136] [37 20 9] [36 21 144] [36 22 136] [36 23 136] [36 24 9] [35 25 144] [35 26 136] [35 27 9] [34 28 144] [34 29 9] [33 30 17] [32 31 144] [32 32 9] [31 33 17] [30 34 17] [29 35 17] [28 36 17] [27 37 18] [26 37 33] [25 38 18] [24 38 34] [23 38 34] [22 38 33] [21 39 18] [20 39 34] [19 39 34] [18 39 34] [17 39 33] [16 40 18] [15 40 34] [14 40 34] [13 40 34] [12 40 34] [11 40 34] [10 40 34] [9 40 36] [8 39 68] [7 38 68] [6 37 72] [6 36 136] [6 35 136] [6 34 136] [6 33 136] [6 32 136] [6 31 136] [6 30 136] [6 29 136] [6 28 136] [6 27 136] [6 26 136] [6 25 136] [6 24 136] [6 23 136] [6 22 136] [6 21 136]]]]
  
  (def a-model (build-model "tmp/templates/word015.png"))

  (:lineseq* a-model)
  [[[6 16 144]]
   [[[6 17 136] [6 18 136] [6 19 136] [6 20 136] [6 21 136] [6 22 72] [7 23 68] [8 24 36] [9 24 34] [10 24 66] [11 25 36] [12 25 34] [13 25 34] [14 25 18] [15 24 33] [16 24 34] [17 24 18] [18 23 33] [19 23 18] [20 22 17] [21 21 17] [22 20 9] [22 19 144] [23 18 9] [23 17 136] [23 16 136] [23 15 136] [23 14 144] [24 13 9] [24 12 132] [23 11 72] [23 10 132] [22 9 68] [21 8 68] [20 7 66] [19 7 36] [18 6 68] [17 5 66] [16 5 34] [15 5 34] [14 5 34] [13 5 33] [12 6 17] [11 7 17] [10 8 17] [9 9 17] [8 10 144] [8 11 9] [7 12 144] [7 13 136] [7 14 136] [7 15 9]]]]

  (def joc-model (build-model "tmp/templates/word002.png"))

  (:lineseq* joc-model)
  [[[38 5 2] [37 5 34] [36 5 34] [35 5 34] [34 5 34] [33 5 34] [32 5 34] [31 5 34] [30 5 33] [29 6 18] [28 6 33] [27 7 18] [26 7 33] [25 8 18] [24 8 33] [23 9 18] [22 9 34] [21 9 33] [20 10 18] [19 10 33] [18 11 18] [17 11 33] [16 12 17] [15 13 18] [14 13 33] [13 14 17] [12 15 17] [11 16 144] [11 17 9] [10 18 17] [9 19 144] [9 20 9] [8 21 144] [8 22 9] [7 23 144] [7 24 136] [7 25 136] [7 26 136] [7 27 9] [6 28 144] [6 29 136] [6 30 136] [6 31 136] [6 32 136] [6 33 136] [6 34 136] [6 35 136] [6 36 136] [6 37 136] [6 38 136] [6 39 136] [6 40 72] [7 41 132] [7 42 72] [8 43 132] [8 44 136] [8 45 136] [8 46 136] [8 47 72] [9 48 68] [10 49 132] [10 50 72] [11 51 68] [12 52 68] [13 53 68] [14 54 68] [15 55 68] [16 56 68] [17 57 68] [18 58 68] [19 59 36] [20 59 66] [21 60 68] [22 61 68] [23 62 68] [24 63 196]]
   [[[24 64 41]]
    [[25 64 38] [26 64 34] [27 64 34] [28 64 66] [29 65 36] [30 65 82]]]
   [[[31 66 132] [31 67 72] [32 68 68] [33 69 132] [33 70 72] [34 71 132] [34 72 136] [34 73 72] [35 74 68] [36 75 132] [36 76 72] [37 77 132] [37 78 136] [37 79 136] [37 80 136] [37 81 72] [38 82 132] [38 83 9] [37 84 144] [37 85 136] [37 86 9] [36 87 144] [36 88 136] [36 89 9] [35 90 144] [35 91 9] [34 92 17] [33 93 17] [32 94 17] [31 95 17] [30 96 17] [29 97 18] [28 97 34] [27 97 34] [26 97 34] [25 97 34] [24 97 34] [23 97 36] [22 96 66] [21 96 34] [20 96 34] [19 96 34] [18 96 36] [17 95 68] [16 94 68] [15 93 72] [15 92 136] [15 91 132] [14 90 72] [14 89 136] [14 88 136] [14 87 136] [14 86 136] [14 85 136] [14 84 136] [14 83 136] [14 82 136] [14 81 136] [14 80 136] [14 79 136] [14 78 136] [14 77 144] [15 76 17] [16 75 9] [16 74 144] [17 73 17] [18 72 17] [19 71 17] [20 70 9] [20 69 144] [21 68 17] [22 67 17] [23 66 9] [23 65 144]]
    [[31 64 9] [31 63 144] [32 62 17] [33 61 33] [34 61 18] [35 60 17] [36 59 17] [37 58 33] [38 58 18] [39 57 17] [40 56 17] [41 55 33] [42 55 18] [43 54 17] [44 53 33] [45 53 18] [46 52 33] [47 52 18] [48 51 33] [49 51 18] [50 50 17] [51 49 33] [52 49 18] [53 48 17] [54 47 17] [55 46 33] [56 46 18] [57 45 17] [58 44 33] [59 44 34] [60 44 2]]]]
  
  (def ale-model (build-model "tmp/templates/word000.png"))

  (:lineseq* ale-model)
  [[[8 73 1] [7 74 17] [6 75 144] [6 76 136] [6 77 136] [6 78 136] [6 79 136] [6 80 136] [6 81 72] [7 82 132] [7 83 136] [7 84 72] [8 85 68] [9 86 68] [10 87 36] [11 87 66] [12 88 68] [13 89 36] [14 89 34] [15 89 34] [16 89 34] [17 89 18] [18 88 33] [19 88 18] [20 87 9] [20 86 144] [21 85 17] [22 84 9] [22 83 136] [22 82 136] [22 81 144] [23 80 17] [24 79 9] [24 78 136] [24 77 144] [25 76 9] [25 75 136] [25 74 144] [26 73 9] [26 72 136] [26 71 136] [26 70 144] [27 69 9] [27 68 136] [27 67 136] [27 66 136] [27 65 144] [28 64 9] [28 63 144] [29 62 9] [29 61 144] [30 60 9] [30 59 136] [30 58 144] [31 57 9] [31 56 136] [31 55 136] [31 54 144] [32 53 9] [32 52 144] [33 51 9] [33 50 136] [33 49 136] [33 48 144] [34 47 9] [34 46 136] [34 45 136] [34 44 144] [35 43 17] [36 42 9] [36 41 136] [36 40 136] [36 39 144] [37 38 9] [37 37 136] [37 36 144] [38 35 9] [38 34 144] [39 33 9] [39 32 144] [40 31 9] [40 30 136] [40 29 144] [41 28 9] [41 27 144] [42 26 9] [42 25 136] [42 24 132] [41 23 84]]
   [[[42 22 17] [43 21 9] [43 20 144] [44 19 17] [45 18 9] [45 17 136] [45 16 144] [46 15 9] [46 14 136] [46 13 136] [46 12 144] [47 11 5] [46 10 72] [46 9 132] [45 8 68] [44 7 66] [43 7 36] [42 6 66] [41 6 34] [40 6 34] [39 6 34] [38 6 34] [37 6 33] [36 7 17] [35 8 17] [34 9 17] [33 10 144] [33 11 136] [33 12 9] [32 13 144] [32 14 136] [32 15 136] [32 16 72] [33 17 132] [33 18 72] [34 19 68] [35 20 68] [36 21 36] [37 21 34] [38 21 66] [39 22 36] [40 22 66]]]]
  
  (def pi-model (build-model "tmp/templates/word001.png"))

  (def sat-model (build-model "tmp/templates/word005.png"))

  (def om-model (build-model "tmp/templates/word006.png"))

  (def am-model (build-model "tmp/templates/word004.png"))

  (def pat-model (build-model "tmp/templates/word007.png"))

  (def pot-model (build-model "tmp/templates/word008.png"))

  (def por-model (build-model "tmp/templates/word009.png"))
  (def tata-model (build-model "tmp/templates/word010.png"))
  (def ta-model (build-model "tmp/templates/word011.png"))
  (def ap-model (build-model "tmp/templates/word012.png"))
  (def j-model (build-model "tmp/templates/word013.png"))
  (def s-model (build-model "tmp/templates/word014.png"))
  (def o-model (build-model "tmp/templates/word021.png"))
  (def a-model (build-model "tmp/templates/word015.png"))
  (def i-model (build-model "tmp/templates/word016.png"))
  (def m-model (build-model "tmp/templates/word017.png"))
  (def n-model (build-model "tmp/templates/word018.png"))
  (def tz-model (build-model "tmp/templates/word019.png"))
  (def e-model (build-model "tmp/templates/word020.png"))
  (def t-model (build-model "tmp/templates/word022.png"))
  (def p-model (build-model "tmp/templates/word023.png"))
  (def l-model (build-model "tmp/templates/word024.png"))
  (def f-model (build-model "tmp/templates/word025.png"))
  (def c-model (build-model "tmp/templates/word026.png"))
  ;;
  )

      

  #+end_src

* 2025-03-01

- reguli de procesare linseq:
  1. celula finala este vecina cu celula initiala => ltype = 0
  2. secventa paralela: celula finala din s1 este vecina cu celula initiala  din s2 si s1 este ltype 1 => s = s1 + s2
  3. secvente paralela: celula initiala din s1 este vecina cu celula initiala din s2 si celula finala din s1 este vecina cu celula finala din s2 => s = s1 + (invers s2) si ltype = 0
  #+begin_src clojure
  (defn neighbors?
    [[x1 y1 _] [x2 y2 _]]
    (<= (+ (abs (- x1 x2))  (abs (- y1 y2))) 2))
  

  (neighbors? [41 23 84] [42 22 17])
  ;; => true

  ;; rules
  (defn get-ltype
    [lseq]
    (if (neighbors? (first lseq) (last lseq)) 0 1))

  (defn continuation?
    [lseq1 lseq2]
    (and (= (get-ltype lseq1) 1)
         (neighbors? (last lseq1) (first lseq2))))
  
  (defn loop?
    [lseq1 lseq2]
    (and (= (get-ltype lseq1) 1)
         (= (get-ltype lseq2) 1)
         (neighbors? (first lseq1) (first lseq2))
         (neighbors? (last lseq1) (last lseq2))))
  #+end_src

* 2025-03-03

- implementez un proces de "curatare" a lineseq
  #+begin_src clojure
(comment

  (import [cv2 :as cv2])

  (add-tap (bound-fn* utl/print4tap))

  
  (def o-model (build-model "tmp/templates/word021.png"))
  
  (def a-model (build-model "tmp/templates/word015.png"))

  (def joc-model (build-model "tmp/templates/word002.png"))

  (def ale-model (build-model "tmp/templates/word000.png"))

  (def pi-model (build-model "tmp/templates/word001.png"))

  (def sat-model (build-model "tmp/templates/word005.png"))

  (def om-model (build-model "tmp/templates/word006.png"))

  (def am-model (build-model "tmp/templates/word004.png"))

  (def pat-model (build-model "tmp/templates/word007.png"))

  (def pot-model (build-model "tmp/templates/word008.png"))

  (def por-model (build-model "tmp/templates/word009.png"))
  (def tata-model (build-model "tmp/templates/word010.png"))
  (def ta-model (build-model "tmp/templates/word011.png"))
  (def ap-model (build-model "tmp/templates/word012.png"))
  (def j-model (build-model "tmp/templates/word013.png"))
  (def s-model (build-model "tmp/templates/word014.png"))
  (def o-model (build-model "tmp/templates/word021.png"))
  (def a-model (build-model "tmp/templates/word015.png"))
  (def i-model (build-model "tmp/templates/word016.png"))
  (def m-model (build-model "tmp/templates/word017.png"))
  (def n-model (build-model "tmp/templates/word018.png"))
  (def tz-model (build-model "tmp/templates/word019.png"))
  (def e-model (build-model "tmp/templates/word020.png"))
  (def t-model (build-model "tmp/templates/word022.png"))
  (def p-model (build-model "tmp/templates/word023.png"))
  (def l-model (build-model "tmp/templates/word024.png"))
  (def f-model (build-model "tmp/templates/word025.png"))
  (def c-model (build-model "tmp/templates/word026.png"))


  (defn neighbors?
    [[x1 y1 _] [x2 y2 _]]
    (<= (+ (abs (- x1 x2))  (abs (- y1 y2))) 2))
  

  (neighbors? [41 23 84] [42 22 17])
  ;; => true

  ;; rules
  (defn get-ltype
    [lseq]
    (if (neighbors? (first lseq) (last lseq)) 0 1))

  (defn continuation?
    [lseq1 lseq2]
    (neighbors? (last lseq1) (first lseq2)))
  
  (defn loop?
    [lseq1 lseq2]
    (and (neighbors? (first lseq1) (first lseq2))
         (neighbors? (last lseq1) (last lseq2))))


  (def lineseqs (:lineseq* joc-model))
  (count lineseqs)
  ;; => 3

  (count (first lineseqs))
  ;; => 76
  
  (count (second lineseqs))
  ;; => 2
  
  (defn nested-levels [v]
    (if (vector? v)
      (if (empty? v)
        1
        (let [max-nested (apply max (map nested-levels v))]
          (inc max-nested)))
      0))

  ;; Usage examples
  (nested-levels [1 2 3])               ; => 1
  (nested-levels [[1 2] [3 [4 5]]])     ; => 2
  (nested-levels [[[1]] [[2]]])         ; => 3
  (nested-levels "not a vector")        ; => 0

  (nested-levels lineseqs)
  ;; => 4

  (nested-levels (first lineseqs))
  ;; => 2

  (nested-levels (second lineseqs))
  ;; => 3

  (nested-levels (last lineseqs))
  ;; => 3

  (into [[1 2 3] [4 5 6]])

  (filter identity [1 nil 2 3 4 nil])
  ;; => (1 2 3 4)

  (defn parallel-lineseq?
    [lseq]
    (= (nested-levels lseq) 3))

  (defn process-lineseq
    [{:keys [prev res modifs-count]} lseq]
    (if-not (parallel-lineseq? lseq)
      (cond
        (= (get-ltype lseq) 0)
        {:prev nil
         :res (filterv identity  (conj res prev lseq))
         :modifs-count modifs-count}
        (and prev (continuation? prev lseq))
        {:prev (into prev lseq)
         :res res
         :modifs-count (inc modifs-count)}
        :else
        {:prev lseq
         :res (filterv identity (conj res prev))
         :modifs-count modifs-count})
      (let [[lseq1 lseq2] lseq]
        (cond
          (= (or (get-ltype lseq1) 0) (= (get-ltype lseq2) 0))
          {:prev nil
           :res (filterv identity  (conj res prev lseq1 lseq2))
           :modifs-count modifs-count}
          (and prev (continuation? prev lseq1))
          {:prev lseq2
           :res (filterv identity  (conj res (into prev lseq1)))
           :modifs-count (inc modifs-count)}
          (loop? lseq1 lseq2)
          {:prev nil
           :res (filterv identity  (conj res prev (into lseq1 (rseq lseq2))))
           :modifs-count modifs-count}
          :else
          {:prev lseq2
           :res (filterv identity  (conj res prev lseq1))
           :modifs-count modifs-count}))))

  (defn format-lineseq
    [lineseq]
    (let [{:keys [prev res modifs-count] :as acc} (reduce process-lineseq
                                                          {:prev nil
                                                           :res []
                                                           :modifs-count 0}
                                                          lineseq)
          new-lineseq (filterv identity (conj res prev))]
      (tap> acc)
      (if (zero? modifs-count)
        (mapv (fn [ls] {:ltype (get-ltype ls) :line (mapv #(subvec % 0 2) ls) :numseq (mapv last ls)}) new-lineseq)
        (format-lineseq new-lineseq))))

  (def lseqs2  (format-lineseq lineseqs))
  lseqs2

  (utl/show-matrix (utl/cells2matrix [100 100] (-> lseqs2
                                                   second
                                                   :line)))

  (defn build-model
    [fileimage]
    (let [mat* (image2matrix (cv2/imread fileimage))
          lineseq* (matrix2lineseq mat*)
          lineseq (format-lineseq lineseq*)
          model {:lineseq* lineseq*
                 :lineseq lineseq}]
      (tap> model)
      (doseq [ls lineseq]
        (utl/show-matrix (utl/cells2matrix [100 100] (:line ls))))
      (assoc model :mat* mat*)))
  

  (def o-model (build-model "tmp/templates/word021.png"))
  

  
  

  ;;
  )
  #+end_src

* 2025-03-04

- bug secventa paralela cu o singura ramura (converter.lpy):
  #+begin_src clojure
(comment

  (import [cv2 :as cv2])

  (add-tap (bound-fn* utl/print4tap))

  

  (defn neighbors?
    [[x1 y1 _] [x2 y2 _]]
    (<= (+ (abs (- x1 x2))  (abs (- y1 y2))) 2))
  

  (neighbors? [41 23 84] [42 22 17])
  ;; => true

  ;; rules
  (defn get-ltype
    [lseq]
    (if (and (> (count lseq) 1) (neighbors? (first lseq) (last lseq))) 0 1))

  (defn continuation?
    [lseq1 lseq2]
    (neighbors? (last lseq1) (first lseq2)))
  
  (defn loop?
    [lseq1 lseq2]
    (and (neighbors? (first lseq1) (first lseq2))
      (neighbors? (last lseq1) (last lseq2))))


  (defn nested-levels [v]
    (if (vector? v)
      (if (empty? v)
        1
        (let [max-nested (apply max (map nested-levels v))]
          (inc max-nested)))
      0))

  ;; Usage examples
  (nested-levels [1 2 3])               ; => 1
  (nested-levels [[1 2] [3 [4 5]]])     ; => 2
  (nested-levels [[[1]] [[2]]])         ; => 3
  (nested-levels "not a vector")        ; => 0

  (nested-levels [[6 16 144]])
  ;; => 2

  (parallel-lineseq? [[6 16 144]])
  
  (get-ltype [[6 16 144]])
  ;; => 1

  (count [[6 16 144]])
  ;; => 1
  
  
  (defn parallel-lineseq?
    [lseq]
    (= (nested-levels lseq) 3))

  (defn parallel2liniar
    "Transform a one line parallel sequence into a liniar sequence"
    [lseq]
    (if (and (parallel-lineseq? lseq) (= (count lseq) 1))
      (first lseq)
      lseq))
  




  
  (defn process-lineseq
    [{:keys [prev res modifs-count] :as state} line-seq]
    (tap> (-> state
            (dissoc :res)
            (assoc :lseq line-seq)))
    (let [lseq (parallel2liniar line-seq)]
      (if (parallel-lineseq? lseq)
        (let [[lseq1 lseq2] lseq]
          (cond
            (= (or (get-ltype lseq1) 0) (= (get-ltype lseq2) 0))
            {:prev nil
             :res (filterv identity  (conj res prev lseq1 lseq2))
             :modifs-count modifs-count}
            (loop? lseq1 lseq2)
            {:prev nil
             :res (filterv identity  (conj res prev (into lseq1 (rseq lseq2))))
             :modifs-count modifs-count}
            :else
            {:prev lseq2
             :res (filterv identity  (conj res prev lseq1))
             :modifs-count modifs-count}))
        (cond
        (= (get-ltype lseq) 0)
        {:prev nil
         :res (filterv identity  (conj res prev lseq))
         :modifs-count modifs-count}
        (= (count prev) 1) ; single cell prev, add it to the lseq
        {:prev (into prev lseq)
         :res res
         :modifs-count (inc modifs-count)}
        (and prev (loop? prev lseq))
        {:prev nil
         :res (filterv identity  (conj res (into prev (rseq lseq))))
         :modifs-count (inc modifs-count)}
        :else
        {:prev lseq
         :res (filterv identity (conj res prev))
         :modifs-count modifs-count}))))

  (defn format-lineseq
    [lineseq]
    (let [{:keys [prev res modifs-count] :as acc} (reduce process-lineseq
                                                    {:prev nil
                                                     :res []
                                                     :modifs-count 0}
                                                    lineseq)
          new-lineseq (filterv identity (conj res prev))]
      (tap> acc)
      (if (zero? modifs-count)
        (mapv (fn [ls] {:ltype (get-ltype ls) :line (mapv #(subvec % 0 2) ls) :numseq (mapv last ls)}) new-lineseq)
        (format-lineseq new-lineseq))))


  (defn build-model
    [fileimage]
    (let [mat* (image2matrix (cv2/imread fileimage))
          lineseq* (matrix2lineseq mat*)
          _ (tap> {:lineseq* lineseq*})
          lineseq (format-lineseq lineseq*)
          model {:lineseq lineseq}]
      (tap> model)
      (doseq [ls lineseq]
        (utl/show-matrix (utl/cells2matrix [100 100] (:line ls))))
      (assoc model
        :mat* mat*
        :lineseq* lineseq*)))

  

  (def a-model (build-model "tmp/templates/word015.png"))
  (def ale-model (build-model "tmp/templates/word000.png"))
  (def am-model (build-model "tmp/templates/word004.png"))
  (def ap-model (build-model "tmp/templates/word012.png"))
  (def c-model (build-model "tmp/templates/word026.png"))
  (def e-model (build-model "tmp/templates/word020.png"))
  (def f-model (build-model "tmp/templates/word025.png"))
  (def i-model (build-model "tmp/templates/word016.png"))
  (def j-model (build-model "tmp/templates/word013.png"))
  (def joc-model (build-model "tmp/templates/word002.png"))
  (def l-model (build-model "tmp/templates/word024.png"))
  (def m-model (build-model "tmp/templates/word017.png"))
  (def mos-model (build-model "tmp/templates/word003.png"))
  (def n-model (build-model "tmp/templates/word018.png"))
  (def o-model (build-model "tmp/templates/word021.png"))
  (def om-model (build-model "tmp/templates/word006.png"))
  (def p-model (build-model "tmp/templates/word023.png"))
  (def pat-model (build-model "tmp/templates/word007.png"))
  (def pi-model (build-model "tmp/templates/word001.png"))
  (def por-model (build-model "tmp/templates/word009.png"))
  (def pot-model (build-model "tmp/templates/word008.png"))
  (def s-model (build-model "tmp/templates/word014.png"))
  (def sat-model (build-model "tmp/templates/word005.png"))
  (def t-model (build-model "tmp/templates/word022.png"))
  (def ta-model (build-model "tmp/templates/word011.png"))
  (def tata-model (build-model "tmp/templates/word010.png"))
  (def tz-model (build-model "tmp/templates/word019.png"))

  ;;
  )
  #+end_src

* 2025-03-05
   #+begin_src clojure
(comment

  (import [cv2 :as cv2])

  (add-tap (bound-fn* utl/print4tap))

  (defn reverse-loop?
    "True if the 2 line sequences build a loop, second lseq is reversed"
    [lseq1 lseq2]
    (and (neighbors? (first lseq1) (last lseq2))
      (neighbors? (last lseq1) (first lseq2))))


  
  (defn process-lineseq
    [{:keys [prev res modifs-count]} line-seq]
    (tap> {:lseq line-seq})
    (tap> {:modifs-count modifs-count})
    (tap> {:prev prev})
    (tap> {:res res})
    (let [lseq (parallel2liniar line-seq)]
      (if (parallel-lineseq? lseq)
        (let [[lseq1 lseq2] lseq]
          (cond
            (= (or (get-ltype lseq1) 0) (= (get-ltype lseq2) 0))
            {:prev nil
             :res (filterv identity  (conj res prev lseq1 lseq2))
             :modifs-count (inc modifs-count)}
            (loop? lseq1 lseq2)
            {:prev nil
             :res (filterv identity  (conj res prev (into lseq1 (rseq lseq2))))
             :modifs-count (inc modifs-count)}
            :else
            {:prev lseq2
             :res (filterv identity  (conj res prev lseq1))
             :modifs-count (inc modifs-count)}))
        (cond
          (= (get-ltype lseq) 0)
          {:prev nil
           :res (filterv identity  (conj res prev lseq))
           :modifs-count modifs-count}
          (small-lineseq? prev) ; small  prev, add it to the lseq
          {:prev (into prev lseq)
           :res res
           :modifs-count (inc modifs-count)}
          (and prev (loop? prev lseq))
          {:prev nil
           :res (filterv identity  (conj res (into prev (rseq lseq))))
           :modifs-count (inc modifs-count)}
          (and prev (reverse-loop? prev lseq))
          {:prev nil
           :res (filterv identity  (conj res (into prev lseq)))
           :modifs-count (inc modifs-count)}
          :else
          {:prev lseq
           :res (filterv identity (conj res prev))
           :modifs-count modifs-count}))))

  (defn format-lineseq
    [lineseq]
    (let [{:keys [prev res modifs-count]} (reduce process-lineseq
                                            {:prev nil
                                             :res []
                                             :modifs-count 0}
                                            lineseq)
          new-lineseq (filterv identity (conj res prev))]
      (tap> {:modifs modifs-count
             :lineseq new-lineseq})
      (if (zero? modifs-count)
        (mapv (fn [ls] {:ltype (get-ltype ls) :line (mapv #(subvec % 0 2) ls) :numseq (mapv last ls)}) new-lineseq)
        (format-lineseq new-lineseq))))

  
  (defn build-model
    [fileimage]
    (let [mat* (image2matrix (cv2/imread fileimage))
          lineseq* (matrix2lineseq mat*)
          _ (tap> {:lineseq* lineseq*})
          lineseq (format-lineseq lineseq*)
          model {:lineseq lineseq}]
      (tap> model)
      (doseq [ls lineseq]
        (utl/show-matrix (utl/cells2matrix [100 100] (:line ls))))
      (assoc model
        :mat* mat*
        :lineseq* lineseq*)))

  (small-lineseq? [])
  (small-lineseq? nil)
  

  (def a-model (build-model "tmp/templates/word015.png"))
  (def ale-model (build-model "tmp/templates/word000.png"))
  (def am-model (build-model "tmp/templates/word004.png"))
  (def ap-model (build-model "tmp/templates/word012.png"))
  (def c-model (build-model "tmp/templates/word026.png"))
  (def e-model (build-model "tmp/templates/word020.png"))
  (def f-model (build-model "tmp/templates/word025.png"))
  (def i-model (build-model "tmp/templates/word016.png"))
  (def j-model (build-model "tmp/templates/word013.png"))
  (def joc-model (build-model "tmp/templates/word002.png"))
  (def l-model (build-model "tmp/templates/word024.png"))
  (def m-model (build-model "tmp/templates/word017.png"))
  (def mos-model (build-model "tmp/templates/word003.png"))
  (def n-model (build-model "tmp/templates/word018.png"))
  (def o-model (build-model "tmp/templates/word021.png"))
  (def om-model (build-model "tmp/templates/word006.png"))
  
  (def p-model (build-model "tmp/templates/word023.png"))
  (def pat-model (build-model "tmp/templates/word007.png"))
  (def pi-model (build-model "tmp/templates/word001.png"))
  (def por-model (build-model "tmp/templates/word009.png"))
  (def pot-model (build-model "tmp/templates/word008.png"))
  (def s-model (build-model "tmp/templates/word014.png"))
  (def sat-model (build-model "tmp/templates/word005.png"))
  (def t-model (build-model "tmp/templates/word022.png"))
  (def ta-model (build-model "tmp/templates/word011.png"))
  (def tata-model (build-model "tmp/templates/word010.png"))
  (def tz-model (build-model "tmp/templates/word019.png"))

  (def lseq
    [[[62 29 8] [62 28 136] [62 27 136] [62 26 136] [62 25 136] [62 24 132] [61 23 72] [61 22 136] [61 21 136] [61 20 136] [61 19 136] [61 18 132] [60 17 72] [60 16 136] [60 15 132] [59 14 68] [58 13 68] [57 12 68] [56 11 68] [55 10 66] [54 10 36] [53 9 68] [52 8 66] [51 8 34] [50 8 34] [49 8 36] [48 7 66] [47 7 34] [46 7 34] [45 7 34] [44 7 34] [43 7 34] [42 7 36] [41 6 66] [40 6 34] [39 6 34] [38 6 34] [37 6 34] [36 6 34] [35 6 34] [34 6 34] [33 6 34] [32 6 34] [31 6 33] [30 7 18] [29 7 34] [28 7 33] [27 8 18] [26 8 33] [25 9 18] [24 9 33] [23 10 17] [22 11 17] [21 12 17] [20 13 144] [20 14 9] [19 15 145]]
     [[[19 16 74]] [[18 16 50] [17 16 34] [16 16 34] [15 16 34] [14 16 33] [13 17 18] [12 17 33] [11 18 17] [10 19 17] [9 20 144] [9 21 9] [8 22 17] [7 23 17] [6 24 144] [6 25 136] [6 26 136] [6 27 136] [6 28 136] [6 29 136] [6 30 136] [6 31 136] [6 32 136] [6 33 136] [6 34 136] [6 35 72] [7 36 132] [7 37 136] [7 38 136] [7 39 72] [8 40 68] [9 41 68] [10 42 68] [11 43 68] [12 44 68] [13 45 68] [14 46 36] [15 46 66] [16 47 36] [17 47 34] [18 47 34] [19 47 34] [20 47 34] [21 47 18] [22 46 17] [23 45 17] [24 44 33] [25 44 18] [26 43 9] [26 42 144] [27 41 17] [28 40 9] [28 39 144] [29 38 9] [29 37 144] [30 36 9] [30 35 136] [30 34 144] [31 33 9] [31 32 136] [31 31 136] [31 30 136] [31 29 136] [31 28 132] [30 27 72] [30 26 136] [30 25 132] [29 24 68] [28 23 68] [27 22 66] [26 22 34] [25 22 36] [24 21 66] [23 21 36] [22 20 68] [21 19 68] [20 18 72] [20 17 132]]]
     []]

    )
  
  (filterv seq [[1 2 3] []])
  ;; => [[1 2 3]]
  

  ;;
  )
   #+end_src

* 2025-03-07

- incerc sa stabilesc standard numseq normalizate pentru fiecare litera:
  #+begin_src clojure
(import [cv2 :as cv2])

(require
  '[steno.converter :as cnv]
  '[steno.utils :as utl])

(add-tap (bound-fn* utl/print4tap))

(defn build-model
  [fileimage]
  (let [mat* (cnv/image2matrix (cv2/imread fileimage))
        lineseq* (cnv/matrix2lineseq mat*)
        _ (tap> {:lseq* lineseq*})
        lineseq (cnv/format-lineseq lineseq*)]
    (tap> {:lseq lineseq})
    (doseq [ls lineseq]
      (utl/show-matrix (utl/cells2matrix [100 100] (:line ls))))
    {:mat* mat*
     :lseq lineseq
     :lseq* lineseq*}))


(def a-model (build-model "tmp/templates/word015.png"))
(def ale-model (build-model "tmp/templates/word000.png"))
(def am-model (build-model "tmp/templates/word004.png"))
(def ap-model (build-model "tmp/templates/word012.png"))
(def c-model (build-model "tmp/templates/word026.png"))

(def e-model (build-model "tmp/templates/word020.png"))
(def f-model (build-model "tmp/templates/word025.png"))
(def i-model (build-model "tmp/templates/word016.png"))
(def j-model (build-model "tmp/templates/word013.png"))
(def joc-model (build-model "tmp/templates/word002.png"))
(def l-model (build-model "tmp/templates/word024.png"))
(def m-model (build-model "tmp/templates/word017.png"))
(def mos-model (build-model "tmp/templates/word003.png"))
(def n-model (build-model "tmp/templates/word018.png"))
(def o-model (build-model "tmp/templates/word021.png"))
(def om-model (build-model "tmp/templates/word006.png"))
(def p-model (build-model "tmp/templates/word023.png"))
(def pat-model (build-model "tmp/templates/word007.png"))

(def pi-model (build-model "tmp/templates/word001.png"))
(def por-model (build-model "tmp/templates/word009.png"))
(def pot-model (build-model "tmp/templates/word008.png"))
(def s-model (build-model "tmp/templates/word014.png"))
(def sat-model (build-model "tmp/templates/word005.png"))

(def t-model (build-model "tmp/templates/word022.png"))
(def ta-model (build-model "tmp/templates/word011.png"))

(def tata-model (build-model "tmp/templates/word010.png"))
(def tz-model (build-model "tmp/templates/word019.png"))


(defn get-loop-start
  [line]
  (reduce (fn [{:keys [min-x min-y min-pos] :as res} [pos [x y]]]
            (if (or (< x min-x) (and (= x min-x) (< y min-y)))
              {:min-x x :min-y y :min-pos pos}
              res))
          {:min-x (first (first line))
           :min-y (second (first line))
           :min-pos 0}
          (map-indexed list (rest line))))


;; a

(def a-00
  (-> a-model
      :lseq
      first))
{:line [[6 16] [6 17] [6 18] [6 19] [6 20] [6 21] [6 22] [7 23] [8 24] [9 24] [10 24] [11 25] [12 25] [13 25] [14 25] [15 24] [16 24] [17 24] [18 23] [19 23] [20 22] [21 21] [22 20] [22 19] [23 18] [23 17] [23 16] [23 15] [23 14] [24 13] [24 12] [23 11] [23 10] [22 9] [21 8] [20 7] [19 7] [18 6] [17 5] [16 5] [15 5] [14 5] [13 5] [12 6] [11 7] [10 8] [9 9] [8 10] [8 11] [7 12] [7 13] [7 14] [7 15]]
 :numseq [144 136 136 136 136 136 72 68 36 34 66 36 34 34 18 33 34 18 33 18 17 17 9 144 9 136 136 136 144 9 132 72 132 68 68 66 36 68 66 34 34 34 33 17 17 17 17 144 9 144 136 136 9]
 :normalized-numseq [136 68 34 33 17 136 72 66 33 17 136]
 :ltype 0}

(def a-01
  (-> ale-model
      :lseq
      second))
  {:line [[33 12] [32 13] [32 14] [32 15] [32 16] [33 17] [33 18] [34 19] [35 20] [36 21] [37 21] [38 21] [39 22] [40 22] [42 22] [43 21] [43 20] [44 19] [45 18] [45 17] [45 16] [46 15] [46 14] [46 13] [46 12] [47 11] [46 10] [46 9] [45 8] [44 7] [43 7] [42 6] [41 6] [40 6] [39 6] [38 6] [37 6] [36 7] [35 8] [34 9] [33 10] [33 11]]
   :numseq [9 144 136 136 72 132 72 68 68 36 34 66 36 66 17 9 144 17 9 136 144 9 136 136 144 5 72 132 68 66 36 66 34 34 34 34 33 17 17 17 144 136]
   :normalized-numseq [136 68 36 17 136 68 34 17 144]
   :ltype 0}
  



(let [ns (:numseq a-01)
      pos (:min-pos (get-loop-start (:line a-01)))
      new-ns (into (subvec ns pos) (subvec ns 0 pos))]
  (cnv/normalize-numseq new-ns cnv/normalize-bin-size))
;; => [136 68 36 17 136 68 34 17 144]

;; => [9 144 136 136 72 132 72 68 68 36 34 66 36 66 17 9 144 17 9 136 144 9 136 136 144 5 72 132 68 66 36 66 34 34 34 34 33 17 17 17 144 136]


(def a-02
  {:line [[11 24] [12 24] [13 25] [14 26] [15 26] [16 26] [17 26] [18 27] [19 27] [20 28] [21 29] [22 29] [23 30] [23 31] [24 32] [24 33] [24 34] [24 35] [24 36] [24 37] [23 38] [23 39] [22 40] [21 41] [21 42] [20 43] [19 44] [18 45] [17 46] [16 46] [15 46] [14 45] [13 45] [12 45] [11 45] [10 44] [9 44] [8 43] [7 42] [6 41] [5 40] [5 39] [5 38] [5 37] [5 36] [5 35] [5 34] [5 33] [5 32] [5 31] [6 30] [6 29] [6 28] [6 27] [7 26] [8 25] [9 24]]
   :numseq [36 66 68 36 34 34 66 36 66 68 36 66 132 72 132 136 136 136 136 9 144 9 17 144 9 17 17 17 18 34 36 66 34 34 36 66 36 68 68 68 72 136 136 136 136 136 136 136 136 144 9 136 136 144 17 17 17]
   :normalized-numseq [36 36 66 132 136 17 18 36 68 136 136 136 17]
   :ltype 0})

(def a-03
  {:line [[21 8] [20 8] [19 7] [18 6] [17 6] [16 6] [15 6] [14 6] [13 6] [12 6] [11 7] [10 7] [9 7] [8 8] [7 9] [6 10] [6 11] [6 12] [6 13] [6 14] [6 15] [6 16] [6 17] [7 18] [8 19] [9 20] [10 21] [11 22] [12 22] [13 23] [14 23] [15 23] [16 23] [17 23] [18 22] [19 21] [20 20] [21 19] [22 18] [22 17] [22 16] [22 15] [23 14] [23 13] [23 12] [23 11] [23 10]]
   :numseq [66 36 68 66 34 34 34 34 34 33 18 34 33 17 17 144 136 136 136 136 136 136 72 68 68 68 68 36 66 36 34 34 34 18 17 17 17 17 9 136 136 144 9 136 136 136 132]
   :normalized-numseq [66 36 34 33 136 68 36 18 17 136 132]
   :ltype 1})

(def a-04
  (-> pat-model
      :lseq
      second))
{:line [[35 15] [35 14] [35 13] [35 12] [35 11] [35 10] [35 9] [36 8] [37 7] [38 7] [39 6] [40 6] [41 5] [42 5] [43 5] [44 5] [45 5] [46 6] [47 6] [48 6] [49 7] [50 8] [51 9] [52 10] [52 11] [52 12] [52 13] [52 14] [51 15] [50 15] [49 16] [48 17] [47 17] [46 17] [45 17] [44 17] [43 17] [42 17] [41 17] [40 17] [39 17] [38 18] [37 18]]
 :numseq [9 136 136 136 136 136 144 17 33 18 33 18 33 34 34 34 66 36 34 66 68 68 68 132 136 136 136 9 18 33 17 18 34 34 34 34 34 34 34 34 33 18 35]
 :normalized-numseq [9 136 33 34 66 132 18 34 34 35]
 :ltype 1}

(def a-05
  (-> sat-model
      :lseq
      second))
{:line [[19 51] [19 50] [19 49] [19 48] [19 47] [19 46] [18 45] [18 44] [18 43] [17 42] [16 41] [15 41] [14 40] [13 40] [12 40] [11 40] [10 40] [9 41] [8 41] [7 42] [6 43] [6 44] [7 45] [7 46] [7 47] [7 48] [7 49] [8 50] [9 51] [10 51] [11 51] [12 52] [13 52] [14 52] [15 53] [16 53] [17 53] [18 52]]
 :numseq [41 200 136 136 136 132 72 136 132 68 66 36 66 34 34 34 33 18 33 17 144 72 132 136 136 136 72 68 36 34 66 36 34 66 36 34 82 17]
 :normalized-numseq [41 136 72 34 33 136 66 36 82]
 :ltype 0}

(def a-06
  (-> ta-model
      :lseq
      second))
{:line [[21 49] [20 49] [19 49] [18 48] [17 48] [16 48] [15 48] [14 47] [13 47] [12 47] [11 47] [10 47] [9 47] [8 47] [7 48] [6 49] [6 50] [6 51] [6 52] [6 53] [6 54] [6 55] [6 56] [6 57] [6 58] [7 59] [8 60] [9 61] [10 62] [11 63] [12 64] [13 64] [14 64] [15 64] [16 64] [17 64] [18 64] [19 64] [20 64] [21 63] [22 62] [23 61] [24 60] [25 59] [25 58] [25 57] [25 56] [24 55] [24 54] [24 53] [24 52] [23 51] [23 50] [22 49]]
 :numseq [50 34 36 66 34 34 36 66 34 34 34 34 34 33 17 144 136 136 136 136 136 136 136 136 72 68 68 68 68 68 36 34 34 34 34 34 34 34 18 17 17 17 17 9 136 136 132 72 136 136 132 72 132 74]
 :normalized-numseq [50 34 34 34 136 136 68 34 18 17 132 74]
 :ltype 0}
  


;; p

(def p-01
  (-> pat-model
      :lseq
      first))
{:line [[5 16] [6 16] [7 16] [8 16] [9 16] [10 16] [11 16] [12 16] [13 16] [14 16] [15 16] [16 16] [17 16] [18 17] [19 17] [20 17] [21 17] [22 17] [23 17] [24 17] [25 17] [26 17] [27 17] [28 16] [29 16] [30 16] [31 16] [32 16] [33 16] [34 16]]
 :numseq [32 34 34 34 34 34 34 34 34 34 34 34 66 36 34 34 34 34 34 34 34 34 18 33 34 34 34 34 34 82]
 :normalized-numseq [32 34 34 34 34 34 34]
 :ltype 1}

;; s
(def s-01
  (-> sat-model
      :lseq
      first))
  {:line [[21 5] [22 5] [23 5] [24 6] [25 6] [26 7] [27 7] [28 7] [29 7] [30 7] [31 7] [32 7] [33 8] [34 8] [35 9] [36 10] [37 11] [38 11] [39 12] [40 13] [41 14] [42 14] [43 15] [44 16] [44 17] [45 18] [45 19] [46 20] [46 21] [46 22] [47 23] [47 24] [47 25] [47 26] [47 27] [46 28] [46 29] [46 30] [46 31] [46 32] [46 33] [45 34] [45 35] [44 36] [44 37] [43 38] [43 39] [43 40] [43 41] [42 42] [41 42] [40 43] [39 44] [38 45] [37 45] [36 46] [35 47] [34 47] [33 48] [32 48] [31 49] [30 49] [29 49] [28 50] [27 50] [26 51] [25 51] [24 51] [23 51] [22 51] [21 51] [20 51]]
   :numseq [32 34 66 36 66 36 34 34 34 34 34 66 36 66 68 68 36 66 68 68 36 66 68 132 72 132 72 132 136 72 132 136 136 136 9 144 136 136 136 136 9 144 9 144 9 144 136 136 9 18 33 17 17 18 33 17 18 33 18 33 18 34 33 18 33 18 34 34 34 34 34 38]
   :normalized-numseq [32 36 34 66 66 72 132 136 136 144 33 17 18 33 34 38]
   :ltype 1}


;; t

(def t-01
  (-> pat-model
      :lseq
      last))
{:line [[35 17] [36 18] [36 19] [36 20] [35 21] [35 22] [35 23] [35 24] [35 25] [35 26] [35 27] [35 28] [35 29] [35 30] [35 31] [35 32] [34 33] [34 34] [34 35] [34 36] [34 37] [34 38] [34 39] [34 40] [34 41] [34 42] [34 43] [34 44] [34 45] [34 46] [34 47]]
 :numseq [68 164 152 9 144 136 136 136 136 136 136 136 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 8]
 :normalized-numseq [68 144 136 136 136 136 136]
 :ltype 1}

(def t-02
  (-> sat-model
      :lseq
      last))
{:line [[18 54] [18 55] [17 56] [17 57] [17 58] [17 59] [17 60] [17 61] [17 62] [17 63] [17 64] [17 65] [17 66] [17 67] [17 68] [17 69] [17 70] [18 71] [18 72] [18 73] [18 74] [18 75] [18 76] [18 77] [18 78] [18 79] [18 80] [18 81]]
 :numseq [132 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 72 132 136 136 136 136 136 136 136 136 136 8]
 :normalized-numseq [132 136 136 136 136 136 136]
 :ltype 1}

(def t-03
  (-> ta-model
      :lseq
      first))
  {:line [[28 5] [28 6] [28 7] [28 8] [27 9] [26 10] [26 11] [26 12] [26 13] [26 14] [26 15] [25 16] [25 17] [25 18] [25 19] [25 20] [25 21] [25 22] [25 23] [25 24] [24 25] [24 26] [24 27] [24 28] [24 29] [24 30] [24 31] [24 32] [24 33] [24 34] [24 35] [24 36] [24 37] [24 38] [24 39] [24 40] [24 41] [24 42] [24 43] [24 44] [24 45] [23 46] [23 47] [22 48]]
   :numseq [128 136 136 9 17 144 136 136 136 136 9 144 136 136 136 136 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 136 9 144 9 145]
   :normalized-numseq [128 136 136 136 136 136 136 136 136 144]
   :ltype 1}
  
  #+end_src 
