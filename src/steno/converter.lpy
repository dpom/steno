(ns steno.converter
  (:require
    [basilisp.set :as set]
    [steno.utils :as utl]))


(def directions
  [[0  1] ; E
   [1  1] ; SE
   [1  0] ; S
   [1 -1] ; SV
   [0 -1] ; V
   [-1 -1] ; NV
   [-1  0] ; N
   [-1  1] ; NE
   ])


(def pos [2r10000000
          2r01000000
          2r00100000
          2r00010000
          2r00001000
          2r00000100
          2r00000010
          2r00000001])


(def dummy-cell [-1 -1])


(defn image2matrix
  "Convert an image to binary matrix."
  [img]
  (let [[rows cols _] (.- img shape)]
    (mapv (fn [i]
            (mapv (fn [j]
                    (if (bool (zero? (apply + (aget img i j)))) 0 1))
              (range 0 cols)))
      (range 0 rows))))


(defn get-cell-value
  "Get cell value. If row or column index is wrong return 0."
  [mat row column]
  (try
    (aget mat row column)
    (catch Exception e
      0)))


(defn get-neighbor
  "Get the neighbor cell (address and value)."
  [mat [r c] [dr dc]]
  (let [nr (+ r dr)
        nc (+ c dc)]
    [[nr nc] (if (or (neg? nr) (neg? nc))
               0
               (get-cell-value mat nr nc))]))


(defn get-cell-number-and-neighbors
  "Get all neighbors with 1 and the cell number"
  [mat cell]
  (reduce (fn [[neighbors num] dir]
            (let [[np v] (get-neighbor mat cell dir)]
              [(if (zero? v) neighbors (conj neighbors np)) (+ (* num 2) v)]))
    [#{} 0]
    directions))


(defn get-start-cells
  "Find the cells where the word could start."
  [mat]
  (let [max-row (count mat)
        max-col (count (first mat))]
    (loop [acc []
           row 0
           col 0]
      (let [[neighbors _] (get-cell-number-and-neighbors mat [row col])
            new-acc (if (and (= (get-cell-value mat row col) 1)
                          (= (count neighbors) 1))
                      (conj acc [row col])
                      acc)
            new-col (inc col)
            new-row (if (= new-col max-col) (inc row) row)
            new-col (if (= new-row row) new-col 0)]
        (if (= new-row max-row)
          new-acc
          (recur new-acc new-row new-col))))))


(defn get-min-start-cell
  "Return the cell that has the highest probability of being the beginning of the word."
  [start-cells]
  (first
    (reduce (fn [[min-cell sum] cell]
              (let [new-sum (apply + cell)]
                (if (< new-sum sum)
                  [cell new-sum]
                  [min-cell sum])))
      [dummy-cell (float "inf")]
      start-cells)))


(defn get-first-one
  "Return the first cell with the value one."
  [mat]
  (let [max-row (count mat)
        max-col (count (first mat))]
    (loop [row 0
           col 0]
      (if (= (get-cell-value mat row col) 1)
        [row col]
        (let [new-col (inc col)
              new-row (if (= new-col max-col) (inc row) row)
              new-col (if (= new-row row) new-col 0)]
          (if (= new-row max-row)
            dummy-cell
            (recur new-row new-col)))))))


(defn get-start-cell
  [mat]
  (let [cells (get-start-cells mat)]
    (case (count cells)
      0 (get-first-one mat)
      1 (first cells)
      (get-min-start-cell cells))))


(defn get-next-neighbors
  [mat start-cell prev-cell]
  (-> (get-cell-number-and-neighbors mat start-cell)
    first
    (disj prev-cell)))


(defn get-liniar-sequence
  "Return a liniar numeric sequence.

   Params:
   - mat : the word matrix
   - status: (map) status of the extracting process
     - start-cell : [row column]
     - prev-cells : (set) previous cells with value 1 processed

   Returns: status map updated + numseq"
  [mat {:keys [start-cell prev-cells]}]
  (loop [start start-cell
         prev prev-cells
         numseq []]
    (let [[neighbors val] (get-cell-number-and-neighbors mat start)
          new-neighbors (set/difference neighbors prev)
          new-numseq (conj numseq val)
          new-prev (conj prev start)]
      (tap> {:cell start :val val :neighbors new-neighbors})
      (if-not (= (count new-neighbors) 1)
        {:start-cells new-neighbors
         :prev-cells new-prev
         :numseq new-numseq}
        (recur (first new-neighbors) new-prev new-numseq)))))


(defn get-parallel-sequence
  "Return a parallel numeric sequence. The parallel numeric sequence contains usual 2 liniar sequences forming a loop.

   Params:
   - mat : the word matrix
   - status: (map) status of the extracting process
      - start-cells : (set) cells to process
      - prev-cells : (set) previous cells with value 1
  
   Returns: status map updated + numseq  "
  [mat {:keys [start-cells prev-cells] :as state}]
  (tap> state)
  (reduce (fn [acc cell]
            (tap> {:cell cell})
            (tap> acc)
            (if (get (:prev-cells acc) cell)
              acc
              (let [new-seq (get-liniar-sequence mat
                              (assoc acc
                                :start-cell cell))
                    new-acc  {:prev-cells (:prev-cells new-seq)
                              :numseq (conj (:numseq acc) (:numseq new-seq))
                              :start-cells (into (:start-cells acc) (:start-cells new-seq))}]
                (tap> new-acc)
                new-acc)))
    {:prev-cells prev-cells
     :numseq []
     :start-cells #{}}
    start-cells))


(defn extract-neighbors
  "Extract neighbors cells from a cell number"
  [num [x y]]
  (set (filter identity
         (map (fn [[dx dy] p]
                (if (zero? (bit-and num p))
                  nil
                  [(+ x dx) (+ y dy)]))
           directions pos))))


;; module entry points

(defn matrix2numseq
  "Convert a word matrix in a vector of numeric sequences."
  [mat]
  (loop [state {:start-cells #{(get-start-cell mat)}
                :prev-cells #{}
                :numseq []}
         acc []]
    (tap> state)
    (let [new-state (if (= (count (:start-cells state)) 1)
                      (get-liniar-sequence mat (assoc state :start-cell (first (:start-cells state))))
                      (get-parallel-sequence mat state))
          new-acc (conj acc (:numseq new-state))]
      (if (empty? (:start-cells new-state))
        new-acc
        (recur new-state new-acc)))))


(defn numseq2matrix
  "Convert a numeric sequence in a binary matrix"
  [numseq]
  (let [start-cell [100 100]
        cells* (:cells (reduce (fn [{:keys [cells start prev] :as acc} num]
                                 (tap> acc)
                                 (let [new-cells (-> num
                                                   (extract-neighbors start)
                                                   (disj prev))]
                                   (tap> {:new-cells new-cells})
                                   {:cells (into cells new-cells)
                                    :start (first new-cells)
                                    :prev start}))
                         {:cells #{start-cell}
                          :start start-cell
                          :prev dummy-cell}
                         numseq))
        x-min (dec (apply min (map first cells*)))
        y-min (dec (apply min (map second cells*)))
        cells (mapv (fn [[x y]] [(- x x-min) (- y y-min)]) cells*)
        x-max (inc (apply max (map first cells)))
        y-max (inc (apply max (map second cells)))]
    (utl/cells2matrix [x-max y-max] cells)))


(comment

  (import [cv2 :as cv2])

  (def joc-mat* (image2matrix (cv2/imread "tmp/templates/word002.png")))

  (utl/show-matrix joc-mat*)

  (def start-cell (get-start-cell joc-mat*))

  (add-tap (bound-fn* utl/print4tap))

  (def seq0 (get-liniar-sequence joc-mat* {:start-cell start-cell
                                           :prev-cells #{}}))
  seq0
  {:prev-cells #{[26 7] [6 35] [11 17] [34 5] [20 59] [8 21] [22 9] [31 5] [18 58] [7 42] [28 6] [6 34] [7 25] [38 5] [11 16] [23 9] [6 37] [12 15] [10 49] [9 20] [21 9] [12 52] [6 30] [6 33] [32 5] [9 19] [22 61] [19 10] [30 5] [36 5] [6 32] [27 7] [10 18] [10 50] [13 14] [21 60] [6 38] [16 56] [25 8] [7 26] [24 63] [6 28] [8 47] [7 23] [20 10] [37 5] [6 31] [7 41] [16 12] [14 13] [8 46] [17 57] [6 40] [29 6] [7 24] [33 5] [8 45] [14 54] [24 8] [15 13] [11 51] [6 36] [19 59] [9 48] [15 55] [6 39] [8 44] [17 11] [23 62] [35 5] [6 29] [8 22] [13 53] [7 27] [18 11] [8 43]}
   :start-cells #{[24 64] [25 64]}
   :numseq [2 34 34 34 34 34 34 34 33 18 33 18 33 18 33 18 34 33 18 33 18 33 17 18 33 17 17 144 9 17 144 9 144 9 144 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 72 132 72 132 136 136 136 72 68 132 72 68 68 68 68 68 68 68 68 36 66 68 68 68 196]}


  (def seq1 (get-parallel-sequence joc-mat* seq0))
  seq1
  {:prev-cells #{[26 7] [6 35] [11 17] [34 5] [20 59] [8 21] [22 9] [31 5] [18 58] [7 42] [28 6] [27 64] [6 34] [7 25] [38 5] [11 16] [23 9] [6 37] [12 15] [10 49] [9 20] [21 9] [12 52] [6 30] [6 33] [29 65] [32 5] [9 19] [22 61] [19 10] [30 5] [36 5] [6 32] [27 7] [10 18] [10 50] [24 64] [13 14] [21 60] [6 38] [16 56] [25 8] [7 26] [30 65] [24 63] [6 28] [8 47] [7 23] [20 10] [37 5] [6 31] [7 41] [16 12] [14 13] [8 46] [17 57] [6 40] [29 6] [7 24] [33 5] [8 45] [14 54] [24 8] [15 13] [25 64] [11 51] [6 36] [19 59] [9 48] [15 55] [26 64] [6 39] [8 44] [28 64] [17 11] [23 62] [35 5] [6 29] [8 22] [13 53] [7 27] [18 11] [8 43]} :start-cells #{[31 66] [31 64] [23 65] [25 64]} :numseq [[41] [38 34 34 66 36 82]]}

  (def seq3 (get-parallel-sequence joc-mat* seq1))
  seq3
  {:prev-cells #{[26 7] [6 35] [46 52] [18 96] [11 17] [34 5] [20 59] [8 21] [14 78] [43 54] [27 97] [36 75] [22 9] [31 5] [18 58] [31 66] [52 49] [7 42] [37 86] [28 6] [60 44] [42 55] [14 84] [53 48] [27 64] [14 87] [37 85] [14 90] [56 46] [6 34] [7 25] [38 5] [11 16] [39 57] [23 9] [37 79] [6 37] [12 15] [26 97] [44 53] [47 52] [17 73] [10 49] [19 71] [37 58] [49 51] [9 20] [34 72] [35 91] [31 64] [21 9] [14 83] [12 52] [15 93] [21 68] [34 61] [37 84] [6 30] [14 89] [6 33] [50 50] [29 65] [32 5] [29 97] [37 78] [51 49] [15 92] [9 19] [32 94] [48 51] [34 92] [24 97] [37 77] [55 46] [14 79] [32 62] [22 61] [35 90] [14 82] [32 68] [19 10] [30 5] [23 97] [23 65] [14 85] [31 67] [36 5] [6 32] [14 88] [27 7] [33 93] [33 61] [10 18] [37 81] [10 50] [24 64] [13 14] [21 60] [36 59] [6 38] [16 56] [14 81] [25 8] [7 26] [30 65] [59 44] [24 63] [6 28] [8 47] [38 83] [31 63] [22 67] [31 95] [7 23] [20 10] [37 5] [6 31] [37 80] [36 87] [58 44] [7 41] [34 73] [16 12] [21 96] [54 47] [14 77] [14 13] [38 82] [20 96] [16 75] [8 46] [30 96] [17 57] [15 91] [33 70] [14 80] [6 40] [25 97] [18 72] [28 97] [29 6] [7 24] [20 70] [33 69] [57 45] [33 5] [23 66] [14 86] [17 95] [8 45] [14 54] [24 8] [15 13] [36 76] [25 64] [11 51] [41 55] [40 56] [35 60] [6 36] [36 89] [16 74] [19 59] [9 48] [15 55] [26 64] [34 71] [6 39] [15 76] [8 44] [22 96] [45 53] [19 96] [28 64] [35 74] [17 11] [23 62] [36 88] [35 5] [6 29] [38 58] [8 22] [13 53] [7 27] [20 69] [18 11] [16 94] [8 43]}
   :start-cells #{}
   :numseq [[132 72 68 132 72 132 136 72 68 132 72 132 136 136 136 72 132 9 144 136 9 144 136 9 144 9 17 17 17 17 17 18 34 34 34 34 34 36 66 34 34 34 36 68 68 72 136 132 72 136 136 136 136 136 136 136 136 136 136 136 136 144 17 9 144 17 17 17 9 144 17 17 9 144] [9 144 17 33 18 17 17 33 18 17 17 33 18 17 33 18 33 18 33 18 17 33 18 17 17 33 18 17 33 34 2]]}

  (matrix2numseq joc-mat*)
  ;; => [[2 34 34 34 34 34 34 34 33 18 33 18 33 18 33 18 34 33 18 33 18 33 17 18 33 17 17 144 9 17 144 9 144 9 144 136 136 136 9 144 136 136 136 136 136 136 136 136 136 136 136 72 132 72 132 136 136 136 72 68 132 72 68 68 68 68 68 68 68 68 36 66 68 68 68 196] [[41] [38 34 34 66 36 82]] [[132 72 68 132 72 132 136 72 68 132 72 132 136 136 136 72 132 9 144 136 9 144 136 9 144 9 17 17 17 17 17 18 34 34 34 34 34 36 66 34 34 34 36 68 68 72 136 132 72 136 136 136 136 136 136 136 136 136 136 136 136 144 17 9 144 17 17 17 9 144 17 17 9 144] [9 144 17 33 18 17 17 33 18 17 17 33 18 17 33 18 33 18 33 18 17 33 18 17 17 33 18 17 33 34 2]]]
  ;;
  )
