(ns steno.translator
  (:require
   [steno.converter :as cnv]
   [steno.utils :as utl]
   [steno.reference-sequences :as rs])
  (:import [cv2 :as cv2]))

(def ^{:doc "The length of the shortest reference sequence"} min-refseq
  (let [{:keys [len len-tolerance]} (last rs/type-1-refsequences)]
    (- len len-tolerance)))

(def ^{:doc "The unknown letter indicator"} unknown-letter "*")

(def tap-topic "translator")

(defn get-freq-diff
  "Compute the difference between a sequence frequencies and a reference one"
  [current reference]
  (reduce (fn [acc freq]
            (+ acc (abs (- (get reference freq) (get current freq 0)))))
          0
          (keys reference)))

(defn check-ref
  "Check if a normalized sequence could be the reference sequence.

   Params:
   - nseq: (vector) the normalized sequence
   - nseq-len: (int) the normalized sequence length
   - result: (vector) the result if the nseq is not equal to refseq
   - refseq: (map) the reference sequence

   Returns: [letter <rest of nseq>] or result"
  [nseq nseq-len result {:keys [letter len len-tolerance freq freq-tolerance] :as refseq}]
  (tap> (select-keys refseq [:letter :len]))
  (if (> nseq-len (- len len-tolerance))
    (let [l (min nseq-len (+ len len-tolerance))
          ns (take l nseq)
          f (frequencies ns)
          t (get-freq-diff f freq)]
      (tap> {:l l :ns ns :f f :t t})
      (if (<= t freq-tolerance)
        (reduced [letter (drop l ns)])
        result))
    result))

(defn translate-numseq
  "Translate a normalized sequence"
  [{:keys [numseq ltype]}]
  (let [dict (if (zero? ltype) rs/type-0-refsequences rs/type-1-refsequences)]
    (loop [s numseq
           acc ""]
      ;; (tap> tap-topic {:nseq s :acc acc})
      (let [l (count s)]
        (if (< l min-refseq)
          acc
          (let [[letter new-s] (reduce
                                 #(check-ref s l %1 %2)
                                 [unknown-letter []]
                                 dict)]
            (recur  new-s  (str acc letter))))))))

(defn normalize-line
  "Line item line should start with the cell closest to the origin"
  [model-item]
  (let [line (:line model-item)]
    (if (= 1 (utl/compare-cell (first line)  (last line)))
      (assoc model-item :line (reverse line))
      model-item)))

(defn build-model
  "Build a word model from an image"
  [fileimage]
  (let [mat* (cnv/image2matrix (cv2/imread fileimage))
        lineseq* (cnv/matrix2lineseq mat*)]
    (->> lineseq*
         cnv/format-lineseq
         (map normalize-line)
         (sort-by #(first (:line %)) utl/compare-cell)
         (mapv #(select-keys % [:numseq :len :ltype])))))

(defn translate-word
  "Translate a word (image)"
  [fileimage]
  (->> fileimage
       build-model
       (map translate-numseq)
       (apply str)))

(comment

  (add-tap (bound-fn* utl/print4tap))

  (defn check-translate-word
    [filename expected]
    (format "expected: %s - get: %s" expected (translate-word (str "./test/resources/" filename))))

  (check-translate-word "templates/word007.png" "pat")
  ;; => "expected: pat - get: pat"

  (check-translate-word "templates/word012.png" "ap")
  ;; => "expected: ap - get: ap"

  (def translation-table
    [["templates/word000.png" "are"]
     ["templates/word001.png" "pe"]
     ["templates/word002.png" "joc"]
     ["templates/word003.png" "mos"]
     ["templates/word004.png" "am"]
     ["templates/word005.png" "sat"]
     ["templates/word006.png" "om"]
     ["templates/word007.png" "pat"]
     ["templates/word008.png" "pot"]
     ["templates/word009.png" "ce"]
     ["templates/word010.png" "d"]
     ["templates/word011.png" "ta"]
     ["templates/word012.png" "ap"]
     ["templates/word013.png" "j"]
     ["templates/word014.png" "s"]
     ["templates/word015.png" "a"]
     ["templates/word016.png" "e"]
     ["templates/word017.png" "m"]
     ["templates/word018.png" "n"]
     ["templates/word019.png" "ge"]
     ["templates/word020.png" "i"]
     ["templates/word021.png" "o"]
     ["templates/word022.png" "t"]
     ["templates/word023.png" "p"]
     ["templates/word024.png" "l"]
     ["templates/word025.png" "f"]
     ["templates/word026.png" "c"]])

  (apply check-translate-word (first translation-table))
  ;; => "expected: are - get: ad"

  (require
    '[basilisp-pprint.pprint :as p])

  (p/pprint
    (mapv #(apply check-translate-word %) translation-table))

  ["expected: are - get: ad"
   "expected: pe - get: b"
   "expected: joc - get: sac"
   "expected: mos - get: maj"
   "expected: am - get: ea"
   "expected: sat - get: j*t"
   "expected: om - get: om"
   "expected: pat - get: pat"
   "expected: pot - get: p*t"
   "expected: ce - get: pol"
   "expected: d - get: d"
   "expected: ta - get: la"
   "expected: ap - get: ap"
   "expected: j - get: j"
   "expected: s - get: j"
   "expected: a - get: a"
   "expected: e - get: i"
   "expected: m - get: n"
   "expected: n - get: n"
   "expected: ge - get: l"
   "expected: i - get: e"
   "expected: o - get: o"
   "expected: t - get: t"
   "expected: p - get: p"
   "expected: l - get: l"
   "expected: f - get: *"
   "expected: c - get: c"]

  ;;
  )
